import os

# å¯¼å…¥JSONå¤„ç†æ¨¡å—
import json
from fix_json_display import fix_url_analysis_result
from linebot.exceptions import InvalidSignatureError
from linebot.models import (
MessageEvent, TextMessage, TextSendMessage, FlexSendMessage,
QuickReply, QuickReplyButton, MessageAction, PostbackEvent, PostbackAction,
BubbleContainer, BoxComponent, ButtonComponent, TextComponent,
CarouselContainer, URIAction, SeparatorComponent
)
from dotenv import load_dotenv
import openai
import logging
from firebase_manager import FirebaseManager
import random
import datetime  # å°å…¥datetimeç”¨æ–¼æ™‚é–“æ¯”è¼ƒ
import re
import requests  # æ·»åŠ  requests åº«ç”¨æ–¼å±•é–‹çŸ­ç¶²å€

load_dotenv()

app = Flask(__name__)

# Line API è¨­å®š
line_bot_api = LineBotApi(os.environ.get('LINE_CHANNEL_ACCESS_TOKEN', ''))
handler = WebhookHandler(os.environ.get('LINE_CHANNEL_SECRET', ''))

# OpenAIè¨­å®š
openai.api_key = os.environ.get('OPENAI_API_KEY', '')

# è¨­ç½®æ—¥èªŒ
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# åˆå§‹åŒ–Firebaseç®¡ç†å™¨
firebase_manager = FirebaseManager.get_instance()

# ç”¨æˆ¶éŠæˆ²ç‹€æ…‹
user_game_state = {}

# ç”¨æˆ¶æœ€å¾ŒèŠå¤©æ™‚é–“è¨˜éŒ„
user_last_chat_time = {}
user_pending_analysis = {} # ç”¨æ–¼è¿½è¹¤ç­‰å¾…ç”¨æˆ¶æ¾„æ¸…çš„åˆ†æè«‹æ±‚
first_time_chatters = set()  # è¿½è¹¤é¦–æ¬¡èŠå¤©çš„ç”¨æˆ¶

CHAT_TIP_PROBABILITY = 0.3 # é–’èŠæ™‚å›è¦†é˜²è©å°çŸ¥è­˜çš„æ©Ÿç‡

# å®šç¾©é—œéµè©å’Œæ¨¡å¼
function_inquiry_keywords = ["åŠŸèƒ½", "å¹«åŠ©", "æœƒä»€éº¼", "èƒ½åšä»€éº¼", "ä½¿ç”¨èªªæ˜", "ä½ æ˜¯èª°"]
follow_up_patterns = ["è¢«é¨™", "è©é¨™", "å¯ç–‘", "ä¸ç¢ºå®š", "å¹«æˆ‘çœ‹çœ‹", "é€™æ˜¯è©é¨™å—", "é€™æ˜¯çœŸçš„å—"]
potato_game_trigger_keywords = ["é¸å“ªé¡†åœŸè±†", "ç©éŠæˆ²", "åœŸè±†éŠæˆ²", "é¸åœŸè±†", "é¸åœŸè±†éŠæˆ²", "é–‹å§‹éŠæˆ²"]
url_analysis_keywords = ["åˆ†æé€™å€‹ç¶²ç«™", "ç¶²å€åˆ†æ", "é€£çµåˆ†æ", "ç¶²ç«™åˆ†æ", "åˆ¤æ–·ç¶²ç«™", "åˆ¤æ–·ç¶²å€"]

# URLæ­£å‰‡è¡¨é”å¼æ¨¡å¼
url_pattern = re.compile(r'https?://\S+')

# å®šç¾©é˜²è©å°çŸ¥è­˜
anti_fraud_tips = [
"ğŸ” æ”¶åˆ°ä¸æ˜é€£çµï¼Ÿå…ˆç¢ºèªç™¼ä¿¡äººèº«åˆ†ï¼Œå†ä¸‰æ€è€Œå¾Œè¡Œã€‚é»æ“Šå‰å•è‡ªå·±ï¼šé€™çœŸçš„å¿…è¦å—ï¼Ÿ",
"ğŸ” è«‹å®šæœŸæ›´æ›å¯†ç¢¼ï¼Œä¸¦é¿å…åœ¨ä¸åŒå¹³å°ä½¿ç”¨ç›¸åŒçš„å¯†ç¢¼çµ„åˆã€‚å»ºè­°ä½¿ç”¨å¯†ç¢¼ç®¡ç†å·¥å…·ï¼",
"ğŸ“± æ¥åˆ°è‡ªç¨±éŠ€è¡Œã€è­¦æ–¹çš„é›»è©±ï¼Ÿæ›æ–·å¾Œï¼Œä¸»å‹•æ’¥æ‰“å®˜æ–¹é›»è©±ç¢ºèªï¼Œä¸è¦å›æ’¥å°æ–¹æä¾›çš„è™Ÿç¢¼ã€‚",
"ğŸ’° æŠ•è³‡å ±é…¬ç‡é«˜å¾—ä¸åˆç†ï¼Ÿè¨˜ä½ï¼šå¤©ä¸‹æ²’æœ‰ç™½åƒçš„åˆé¤ï¼Œé«˜å ±é…¬å¿…æœ‰é«˜é¢¨éšªï¼",
"ğŸ¤ ç¶²è·¯äº¤å‹è¦è¬¹æ…ï¼ŒçŸ­æ™‚é–“å…§å°±è«‡åŠé‡‘éŒ¢å¾€ä¾†çš„ã€Œå¥½å‹ã€å¾ˆå¯èƒ½æ˜¯è©é¨™é›†åœ˜ã€‚",
"ğŸ¦ çœŸæ­£çš„éŠ€è¡Œçµ•ä¸æœƒè«‹ä½ æ“ä½œATMã€Œè§£é™¤è¨­å®šã€ã€ã€Œå‡ç´šç³»çµ±ã€æˆ–ã€Œç¢ºèªèº«åˆ†ã€ã€‚",
"ğŸ›’ ç¶²è³¼åªç”¨æ­£è¦å¹³å°ï¼Œäº¤æ˜“æ™‚ç•™åœ¨å¹³å°å…§å®Œæˆï¼Œåˆ‡å‹¿ç§ä¸‹äº¤æ˜“æˆ–æå‰ä»˜æ¬¾ã€‚",
"ğŸ® è³¼è²·éŠæˆ²é»æ•¸å‰ï¼Œå…ˆç¢ºèªç”¨é€”ï¼Œè‹¥æ˜¯çµ¦é™Œç”Ÿäººæˆ–è§£å‡å¸³æˆ¶ä½¿ç”¨ï¼Œæ¥µå¯èƒ½æ˜¯è©é¨™ï¼"
]

# è©é¨™é¡å‹åˆ†é¡
fraud_types = {
"ç¶²è·¯è³¼ç‰©è©é¨™": {
"description": "æ¶‰åŠå‡å†’è³¼ç‰©ç¶²ç«™ã€è™›å‡å•†å“æˆ–ä¸å¯¦å»£å‘Šçš„è©é¨™",
"examples": [
"ğŸ›’ å‡è²·å®¶é¨™è³£å®¶è©é¨™æ¡ˆä¾‹ ğŸ›’\n\nè©é¨™é›†åœ˜å‡æ‰®è²·å®¶æ¥è§¸äºŒæ‰‹å•†å“è³£å®¶ï¼Œè²ç¨±é€éè¦çš®ç­‰å¹³å°äº¤æ˜“ï¼Œå¼•å°è³£å®¶åŠ å…¥å‡å†’å®¢æœLINEå¸³è™Ÿï¼Œä»¥ã€Œç°½ç½²ä¿è­‰æ›¸ã€ã€ã€ŒéŠ€è¡Œèªè­‰ã€ç­‰è—‰å£èª˜å°è³£å®¶é€²è¡Œç¶²è·¯éŠ€è¡Œè½‰å¸³æˆ–LINE Payä»˜æ¬¾ï¼Œå°è‡´å—å®³è€…è²¡ç”¢æå¤±ã€‚\n\nğŸ“Š è³‡æ–™ä¾†æºï¼š165æ‰“è©å„€è¡¨æ¿"
],
"sop": [
"âš ï¸ é˜²ç¯„ç¶²è·¯è³¼ç‰©è©é¨™æ³¨æ„äº‹é … âš ï¸",
"1ï¸âƒ£ æœ‰ç¶²è·¯äº¤æ˜“å•é¡Œï¼Œè«‹æ´½äº¤æ˜“å¹³è‡ºå…¬å‘Šçš„å®˜æ–¹å®¢æœè¯ç¹«æ–¹å¼ï¼Œä¸è¦ä½¿ç”¨é™Œç”Ÿäººæä¾›çš„è¯ç¹«æ–¹å¼",
"2ï¸âƒ£ å …å®ˆå¹³å°å…§éƒ¨äº¤æ˜“ï¼Œä¸è¦è·³å‡ºè¦çš®ã€éœ²å¤©æˆ–å…¶ä»–å¹³å°çš„å°è©±ç³»çµ±",
"3ï¸âƒ£ éŠ€è¡ŒåŠè¦çš®ç­‰å¹³å°ä¸æœƒä»¥ç§äººLINEå¸³è™Ÿè¯ç¹«å®¢æˆ¶",
"4ï¸âƒ£ é‡åˆ°è¦æ±‚ã€Œç°½ç½²ä¿è­‰æ›¸ã€ã€ã€ŒéŠ€è¡Œèªè­‰ã€ç­‰æ“ä½œæ™‚ï¼Œè«‹æé«˜è­¦è¦º",
"5ï¸âƒ£ çµ•å°ä¸è¦ä¾ç…§ä»–äººæŒ‡ç¤ºæ“ä½œç¶²è·¯éŠ€è¡Œæˆ–é€²è¡Œè½‰å¸³",
"6ï¸âƒ£ æœ‰ä»»ä½•ç–‘å•ï¼Œè«‹ç«‹å³æ’¥æ‰“165åè©é¨™å°ˆç·šè«®è©¢"
]
},
"å‡äº¤å‹æŠ•è³‡è©é¨™": {
"description": "é€éç¶²è·¯äº¤å‹å¹³å°æˆ–ç¤¾ç¾¤åª’é«”ï¼Œå‡æ‰®æœ‰å¥½æ„Ÿçš„ç•°æ€§å»ºç«‹æ„Ÿæƒ…é€£çµï¼Œæœ€çµ‚ä»¥å„ç¨®ç†ç”±é¨™å–é‡‘éŒ¢",
"examples": [
"ğŸ’” ç¶²è·¯äº¤å‹è©é¨™æ¡ˆä¾‹ ğŸ’”\n\nè©é¨™è€…å‡æ‰®é«˜ç¤¾ç¶“åœ°ä½äººå£«ï¼ˆå¦‚é†«ç”Ÿã€è»å®˜ã€æ©Ÿé•·ç­‰ï¼‰èˆ‡è¢«å®³è€…åœ¨ç¶²è·¯ä¸Šèªè­˜ä¸¦å»ºç«‹æƒ…æ„Ÿé€£çµï¼Œé•·æœŸå™“å¯’å•æš–å¾Œï¼Œä»¥ç”Ÿç—…éœ€è¦é†«è—¥è²»ã€å¯„é€æµ·å¤–ç¦®ç‰©éœ€ç¹³ç´é—œç¨…ç­‰å„ç¨®ç†ç”±ï¼Œèª˜é¨™è¢«å®³è€…è½‰å¸³æˆ–é¢äº¤é‡‘éŒ¢ã€‚æ­¤é¡è©é¨™ç‰¹åˆ¥é‡å°å¯¡å±…æˆ–æƒ…æ„Ÿç”Ÿæ´»è¼ƒç‚ºå­¤å–®çš„ä¸­è€å¹´äººã€‚\n\nğŸ“Š è³‡æ–™ä¾†æºï¼š165æ‰“è©å„€è¡¨æ¿"
],
"sop": [
"âš ï¸ é˜²ç¯„äº¤å‹æŠ•è³‡è©é¨™æ³¨æ„äº‹é … âš ï¸",
"1ï¸âƒ£ ç¶²å‹è¦‹éƒ½æ²’è¦‹éå»è«‡åŠé‡‘éŒ¢ï¼Œé«˜åº¦å¯èƒ½æ˜¯è©é¨™",
"2ï¸âƒ£ å°æ–¹è‡ªç¨±é•·æœŸåœ¨åœ‹å¤–å·¥ä½œï¼ˆå¦‚è»é†«ã€æ©Ÿé•·ç­‰ï¼‰ä¸”ç„¡æ³•è¦‹é¢ï¼Œä½†å¾ˆå¿«ç™¼å±•æ„Ÿæƒ…é—œä¿‚ï¼Œæ‡‰æé«˜è­¦è¦º",
"3ï¸âƒ£ æ‹’çµ•ä»»ä½•ä»¥ç·Šæ€¥é†«ç™‚è²»ã€é‹è²»ã€ç¨…é‡‘ç­‰åç¾©è¦æ±‚çš„é‡‘éŒ¢å¾€ä¾†",
"4ï¸âƒ£ ä¸è¦è½ä¿¡éœ€è¦å”åŠ©é–‹é€šå¤–å¹£å¸³æˆ¶ã€å€Ÿç”¨å¸³æˆ¶çš„èªªæ³•",
"ç¶²å‹è¦‹éƒ½æ²’è¦‹éå»è«‡åŠé‡‘éŒ¢ï¼Œé«˜åº¦å¯èƒ½æ˜¯è©é¨™",
"å°æ–¹è‡ªç¨±é•·æœŸåœ¨åœ‹å¤–å·¥ä½œï¼ˆå¦‚è»é†«ã€æ©Ÿé•·ç­‰ï¼‰ä¸”ç„¡æ³•è¦‹é¢ï¼Œä½†å¾ˆå¿«ç™¼å±•æ„Ÿæƒ…é—œä¿‚ï¼Œæ‡‰æé«˜è­¦è¦º",
"æ‹’çµ•ä»»ä½•ä»¥ç·Šæ€¥é†«ç™‚è²»ã€é‹è²»ã€ç¨…é‡‘ç­‰åç¾©è¦æ±‚çš„é‡‘éŒ¢å¾€ä¾†",
"ä¸è¦è½ä¿¡éœ€è¦å”åŠ©é–‹é€šå¤–å¹£å¸³æˆ¶ã€å€Ÿç”¨å¸³æˆ¶çš„èªªæ³•",
"é¿å…å”åŠ©é™Œç”Ÿç¶²å‹ç”³è¾¦æ‰‹æ©Ÿé–€è™Ÿæˆ–æä¾›SIMå¡",
"å°æ–¼ç¶²å‹æ‰€æä¾›çš„èº«ä»½è³‡è¨Šï¼Œå˜—è©¦å¤šæ–¹æŸ¥è­‰",
"æœ‰ä»»ä½•ç–‘å•ï¼Œè«‹ç«‹å³æ’¥æ‰“165åè©é¨™å°ˆç·šè«®è©¢",
"å¤šèˆ‡å®¶äººæœ‹å‹åˆ†äº«äº¤å‹æƒ…æ³ï¼Œé¿å…å–®ç¨åšå‡ºè²¡å‹™æ±ºå®š"
]
},
"å‡ä¸­çé€šçŸ¥è©é¨™": {
"description": "å†’å……å®˜æ–¹å–®ä½æˆ–çŸ¥åä¼æ¥­ï¼Œå®£ç¨±ä¸­çä½†éœ€ç¹³ç´æ‰‹çºŒè²»ç­‰è²»ç”¨æ‰èƒ½é ˜ççš„è©é¨™",
"examples": [],
"sop": []
},
"å‡å€ŸéŠ€è¡Œè²¸æ¬¾è©é¨™": {
"description": "å‡å†’é‡‘èæ©Ÿæ§‹äººå“¡ï¼Œå®£å‚³ä½åˆ©å¿«é€Ÿè²¸æ¬¾ï¼Œä½†è¦æ±‚å…ˆæ”¯ä»˜æ‰‹çºŒè²»æˆ–è³¼è²·é»æ•¸",
"examples": [
"ä¸€åæ€¥éœ€è³‡é‡‘å„Ÿé‚„å®¶åº­å‚µå‹™çš„æ°‘çœ¾åœ¨Facebookçœ‹åˆ°åç‚ºã€Œæ•¸ä½é€Ÿeè²¸ã€çš„å»£å‘Šï¼Œæ¨™æ¦œè²¸æ¬¾å¿«é€Ÿã€åˆ©æ¯ä½ä¸”æ‰‹çºŒç°¡å–®ã€‚æ–¼æ˜¯åŠ å…¥äº†ä¸€å€‹åç‚ºã€Œå°åŒ—å¯Œé‚¦éŠ€è¡Œä¿¡è²¸ã€çš„LINEå¸³è™Ÿã€‚åœ¨ç”³è«‹è²¸æ¬¾30è¬å…ƒä¸¦é€šéåˆå¯©å¾Œï¼Œå°æ–¹è¡¨ç¤ºéœ€è¦è³¼è²·ä¸€ä»½é‡‘èè²¸æ¬¾ä¿éšªï¼Œæ‰èƒ½æé«˜ä¿¡ç”¨è©•åˆ†ã€‚å—å®³è€…åŒ¯äº†1è¬5åƒå…ƒåˆ°æŒ‡å®šå¸³æˆ¶å¾Œï¼Œå°æ–¹åˆè¦æ±‚è³¼è²·é»æ•¸å¡ä»¥å¢åŠ ä¿¡è²¸è©•åˆ†ã€‚å—å®³è€…å¤šæ¬¡è³¼è²·é»æ•¸å¡ä¸¦æä¾›çµ¦å°æ–¹ã€‚ä¸ä¹…å¾Œï¼Œå—å®³è€…ç™¼ç¾ç¶²è·¯éŠ€è¡Œå¸³æˆ¶ç„¡æ³•ä½¿ç”¨ï¼Œè¯ç¹«å°æ–¹ä¹Ÿå·²å¤±è¯ã€‚å‘éŠ€è¡Œå®¢æœæŸ¥è©¢å¾Œï¼Œç¢ºèªå¸³æˆ¶å·²è¢«åˆ—å…¥è­¦ç¤ºåå–®ï¼Œä¸”é€™æ ¹æœ¬ä¸æ˜¯å°åŒ—å¯Œé‚¦éŠ€è¡Œçš„æ¥­å‹™ã€‚"
],
"sop": [
"è²¸æ¬¾è«‹æ‰¾åˆæ³•çš„é‡‘èæ©Ÿæ§‹ã€ä¿éšªå…¬å¸è¾¦ç†",
"åˆæ³•è²¸æ¬¾æ©Ÿæ§‹ä¸æœƒè¦æ±‚äº‹å…ˆæ”¯ä»˜æ‰‹çºŒè²»æˆ–ä¿è­‰é‡‘",
"éŠ€è¡Œè¾¦ç†ä¿¡è²¸ï¼Œçµ•ä¸æœƒè¦æ±‚è³¼è²·é»æ•¸å¡æˆ–é å…ˆåŒ¯æ¬¾",
"åˆæ˜¯è²¸æ¬¾ã€åˆæ˜¯é»æ•¸å¡ï¼Œçµ•å°æ˜¯è©é¨™",
"ç›´æ¥å‰å¾€éŠ€è¡Œåˆ†è¡Œæˆ–é€éå®˜æ–¹ç¶²ç«™ç”³è«‹è²¸æ¬¾",
"ä¸è¦é»æ“Šä¸æ˜ä¾†æºçš„è²¸æ¬¾å»£å‘Šé€£çµ",
"ä¸è¦è¼•ä¿¡ã€Œå…è¯å¾µã€å¿«é€Ÿæ ¸è²¸ã€ç­‰å®£å‚³",
"ä¿è­·å€‹äººè³‡æ–™ï¼Œä¸è¼•æ˜“æä¾›èº«åˆ†è­‰å½±æœ¬",
"æœ‰è²¸æ¬¾éœ€æ±‚æ‡‰å‘åˆæ³•é‡‘èæ©Ÿæ§‹è«®è©¢",
"å°æ–¼è¦æ±‚å…ˆåŒ¯æ¬¾æ‰èƒ½è²¸æ¬¾çš„æœå‹™è¦ç‰¹åˆ¥è­¦è¦º",
"ç¢ºèªè²¸æ¬¾æ©Ÿæ§‹æ˜¯å¦ç‚ºé‡‘ç®¡æœƒæ ¸å‡†çš„åˆæ³•æ©Ÿæ§‹",
"è‹¥æœ‰ç–‘æ…®ï¼Œè«‹æ’¥æ‰“165åè©é¨™å°ˆç·šè«®è©¢"
]
},
"å‡å»£å‘Šè©é¨™": {
"description": "é€éç¶²è·¯å¹³å°ç™¼å¸ƒè™›å‡çš„å»£å‘Šè³‡è¨Šï¼Œå¦‚ç§Ÿå±‹ã€ç¥¨åˆ¸ä»£è³¼ã€å·¥ä½œæ©Ÿæœƒç­‰ï¼Œè¦æ±‚é ä»˜è¨‚é‡‘å¾Œæ¶ˆå¤±",
"examples": [
"ä¸€åå¤§å­¸ä¸‰å¹´ç´šå­¸ç”Ÿå› ç‚ºæ²’æœ‰æŠ½ä¸­å­¸æ ¡å®¿èˆï¼Œåœ¨Facebookçš„ç§Ÿå±‹ç‰ˆç¤¾åœ˜çœ‹åˆ°æˆ¿æ±ã€ŒJoyceã€ç™¼ä½ˆçš„ç§Ÿå±‹è¨Šæ¯ã€‚ç…§ç‰‡ä¸­æˆ¿é–“å±‹æ³è‰¯å¥½ï¼Œå‘¨é­ç”Ÿæ´»æ©Ÿèƒ½ä¾¿åˆ©ï¼Œç§Ÿé‡‘åˆç†ä¸”å¯ç”³è«‹ç§Ÿå±‹è£œåŠ©ã€‚å­¸ç”ŸåŠ äº†æˆ¿æ±çš„LINEï¼Œæˆ¿æ±è¡¨ç¤ºå­¸ç”Ÿæ’åœ¨ç¬¬5çµ„çœ‹æˆ¿ï¼Œä½†å‰é¢å·²æœ‰å®¢äººæ‰“ç®—é ä»˜è¨‚é‡‘å„ªå…ˆçœ‹å±‹ã€‚ç‚ºäº†æ¶å…ˆçœ‹å±‹ï¼Œå­¸ç”Ÿç«‹å³åŒ¯äº†ç§Ÿé‡‘åŠ è¨‚é‡‘å…±3è¬å…ƒã€‚ä¹‹å¾Œï¼Œæˆ¿æ±è²ç¨±å…¶ä¸ˆå¤«èª¤æ”¶äº†å…¶ä»–å®¢äººè¨‚é‡‘ï¼Œè«‹å­¸ç”Ÿå…ˆåŒ¯æ¬¾çµ¦é‚£ä½å®¢äººä»¥ä¿ç•™å„ªå…ˆæ¬Šã€‚å­¸ç”Ÿæå‡ºé€€è²»è¦æ±‚å¾Œï¼Œæˆ¿æ±æ¶ˆå¤±ç„¡è¹¤ã€‚"
],
"sop": [
"ç¶²è·¯ç§Ÿå±‹ï¼Œè‹¥è½è¦‹çœ‹å±‹å„ªå…ˆæ¬Šï¼Œæ¥µå¯èƒ½æ˜¯è©é¨™",
"ç¶²è·¯ç§Ÿå±‹æ‡‰æ´½æˆ¿å±‹ä»²ä»‹å…¬å¸æˆ–æ­£è¦ç§Ÿå±‹ç¶²ç«™",
"æ²’æœ‰çœ‹åˆ°æˆ¿å±‹å¯¦é«”å‰ï¼Œä¸è¦æ”¯ä»˜ä»»ä½•è¨‚é‡‘æˆ–ç§Ÿé‡‘",
"åˆæ³•çš„ç§Ÿå±‹æˆ–ç¥¨åˆ¸äº¤æ˜“ä¸æœƒè¦æ±‚é ä»˜æ¬¾é …",
"å°æ–¼æ€¥è¿«æ¨éŠ·ã€Œé™æ™‚å„ªæƒ ã€çš„å»£å‘Šä¿æŒè­¦æƒ•",
"æŸ¥è­‰å»£å‘Šç™¼å¸ƒè€…çš„çœŸå¯¦èº«ä»½å’Œè©•åƒ¹",
"ä½¿ç”¨æœ‰ä¿éšœçš„ç¬¬ä¸‰æ–¹æ”¯ä»˜æˆ–äº¤æ˜“å¹³å°",
"åˆ©ç”¨Googleåœ–ç‰‡æœå°‹åŠŸèƒ½æŸ¥è­‰ç§Ÿå±‹ç…§ç‰‡æ˜¯å¦ç‚ºç›œç”¨",
"è«‹è¦ªå‹é™ªåŒçœ‹æˆ¿ï¼Œé¿å…ç¨è‡ªæ±ºç­–",
"è‹¥æœ‰ç–‘æ…®ï¼Œè«‹æ’¥æ‰“165åè©é¨™å°ˆç·šè«®è©¢"
]
},
"è‰²æƒ…æ‡‰å¬è©è²¡è©é¨™": {
"description": "é€éç¶²è·¯å¹³å°å®£å‚³è‰²æƒ…æœå‹™ï¼Œè¦æ±‚æ”¯ä»˜ã€Œè¨‚é‡‘ã€ã€ã€Œä¿è­‰é‡‘ã€ç­‰è²»ç”¨ï¼Œä½†å¯¦éš›ä¸Šä¸æä¾›ä»»ä½•æœå‹™",
"examples": [
"ä¸€åç”·æ€§åœ¨ç¤¾ç¾¤åª’é«”ä¸Šçœ‹åˆ°æŸç²‰å°ˆæä¾›å¤–é€èŒ¶æœå‹™çš„å»£å‘Šï¼Œä¾¿ç§è¨Šè©¢å•ã€‚å°æ–¹æä¾›äº†å¤šå¼µå¥³æ€§ç…§ç‰‡ä¾›é¸æ“‡ï¼Œä¸¦èªªæ˜åƒ¹æ ¼å’Œæœå‹™å…§å®¹ã€‚è©²ç”·æ€§é¸å®šå¾Œï¼Œå°æ–¹è¡¨ç¤ºéœ€å…ˆæ”¯ä»˜5,000å…ƒçš„è¨‚é‡‘ï¼Œæ‰æœƒå®‰æ’å¥³ä¼´å‰å¾€ã€‚åŒ¯æ¬¾å¾Œï¼Œå°æ–¹åˆè¡¨ç¤ºå› ç‚ºæ˜¯é¦–æ¬¡äº¤æ˜“ï¼Œç‚ºç¢ºä¿å®‰å…¨ï¼Œéœ€å†æ”¯ä»˜5,000å…ƒã€Œä¿è­‰é‡‘ã€ï¼Œæ‰¿è«¾å¥³ä¼´æŠµé”å¾Œå¯é€€é‚„ã€‚ç”·æ€§å†æ¬¡åŒ¯æ¬¾å¾Œï¼Œå°æ–¹åˆä»¥ã€Œè»Šè³‡ã€ã€ã€Œå®‰å…¨æª¢æŸ¥è²»ã€ç­‰ç†ç”±è¦æ±‚é¡å¤–ä»˜æ¬¾ã€‚æ­¤æ™‚ç”·æ€§æ„è­˜åˆ°å¯èƒ½å—é¨™ï¼Œæ‹’çµ•å†ä»˜æ¬¾ä¸¦è¦æ±‚é€€æ¬¾ï¼Œä½†å°æ–¹å·²å°‡å…¶å°é–ï¼Œç„¡æ³•è¯ç¹«ã€‚"
],
"sop": [
"ä»»ä½•è¦æ±‚å…ˆåŒ¯æ¬¾çš„è‰²æƒ…æœå‹™å»£å‘Šï¼Œå¹¾ä¹éƒ½æ˜¯è©é¨™",
"ä¸è¦ç›¸ä¿¡ç¶²è·¯ä¸Šé™Œç”Ÿäººæä¾›çš„è‰²æƒ…æœå‹™",
"é¿å…åœ¨ä¸æ˜ä¾†æºçš„ç¶²ç«™æˆ–ç¤¾ç¾¤åª’é«”ä¸Šå°‹æ‰¾æ­¤é¡æœå‹™",
"ä¿è­·å€‹äººè³‡æ–™ï¼Œé¿å…èº«ä»½è¢«ç›œç”¨æˆ–é­å‹’ç´¢",
"ä¸è¦è¼•ä¿¡ä¸åˆç†çš„æ”¶è²»æ–¹å¼æˆ–ç†ç”±",
"å°æ–¼åè¦†è¦æ±‚ã€Œé¡å¤–è²»ç”¨ã€çš„è¡Œç‚ºæé«˜è­¦è¦º",
"è‰²æƒ…äº¤æ˜“åœ¨å°ç£æ˜¯é•æ³•çš„ï¼Œå¯èƒ½é¢è‡¨æ³•å¾‹é¢¨éšª",
"è‹¥å·²é­è©é¨™ï¼Œæ‡‰ä¿ç•™æ‰€æœ‰é€šè¨Šè¨˜éŒ„ä½œç‚ºè­‰æ“š",
"è‹¥æœ‰ç–‘æ…®ï¼Œè«‹æ’¥æ‰“165åè©é¨™å°ˆç·šè«®è©¢"
]
},
"è™›æ“¬éŠæˆ²è©é¨™": {
"description": "é€ééŠæˆ²å…§èŠå¤©æˆ–ç¤¾ç¾¤åª’é«”æ¥è§¸ç©å®¶ï¼Œæä¾›è™›å‡çš„éŠæˆ²é»æ•¸ã€å¤–æ›æˆ–æœå‹™ï¼Œé¨™å–é‡‘éŒ¢æˆ–å¸³è™Ÿ",
"examples": [
"ä¸€åé«˜ä¸­ç”Ÿåœ¨æŸç·šä¸ŠéŠæˆ²ä¸­èªè­˜ä¸€ä½ã€Œè³‡æ·±ç©å®¶ã€ï¼Œå°æ–¹è¡¨ç¤ºå¯ä»¥å¹«å¿™ä»£è³¼éŠæˆ²é»æ•¸ï¼Œåªéœ€è¦å¸‚åƒ¹çš„ä¸ƒæŠ˜ã€‚é«˜ä¸­ç”Ÿå¿ƒå‹•ä¸å·²ï¼Œå…ˆå¾ŒåŒ¯äº†3,000å…ƒè³¼è²·éŠæˆ²é»æ•¸ã€‚äº¤æ˜“é †åˆ©å¾Œï¼Œã€Œè³‡æ·±ç©å®¶ã€åˆæ¨è–¦ä¸€å€‹èƒ½æå‡è§’è‰²èƒ½åŠ›çš„å¤–æ›ç¨‹å¼ï¼Œè²ç¨±åªè¦å®‰è£å°±èƒ½ç²å¾—éŠæˆ²å„ªå‹¢ã€‚é«˜ä¸­ç”Ÿä¸‹è¼‰å®‰è£äº†è©²ç¨‹å¼ï¼Œä¸ä¹…å¾Œç™¼ç¾éŠæˆ²å¸³è™Ÿè¢«ç›œï¼Œæ‰€æœ‰è™›æ“¬ç‰©å“è¢«è½‰ç§»ï¼Œä¸”è©²ç¨‹å¼é‚„ç«Šå–äº†ä»–é›»è…¦ä¸­çš„å€‹äººè³‡æ–™ï¼Œå°è‡´å…¶çˆ¶æ¯çš„éŠ€è¡Œå¸³æˆ¶é­ç›œåˆ·ã€‚"
],
"sop": [
"åªé€ééŠæˆ²å®˜æ–¹ç®¡é“è³¼è²·éŠæˆ²é»æ•¸æˆ–ç‰©å“",
"ä¸è¦ä¸‹è¼‰ä¾†è·¯ä¸æ˜çš„å¤–æ›æˆ–ä¿®æ”¹ç¨‹å¼",
"ä¿è­·éŠæˆ²å¸³è™Ÿå¯†ç¢¼ï¼Œä¸éš¨æ„æä¾›çµ¦ä»–äºº",
"åƒ¹æ ¼æ˜é¡¯ä½æ–¼å¸‚å ´çš„äº¤æ˜“å¤šç‚ºè©é¨™",
"ä¸è¦ç›¸ä¿¡å¯ä»¥ç ´è§£éŠæˆ²ç³»çµ±çš„èªªæ³•",
"éŠæˆ²å…§äº¤å‹éœ€è¬¹æ…ï¼Œä¸è¼•æ˜“é€éœ²å€‹äººè³‡è¨Š",
"ä½¿ç”¨é›™é‡èªè­‰ä¿è­·é‡è¦éŠæˆ²å¸³è™Ÿ",
"å®šæœŸæ›´æ›å¯†ç¢¼ä¸¦æª¢æŸ¥å¸³è™Ÿå®‰å…¨è¨­ç½®",
"ä¸è¦ä½¿ç”¨èˆ‡å…¶ä»–å¹³å°ç›¸åŒçš„å¯†ç¢¼",
"è‹¥æœ‰ç–‘æ…®ï¼Œè«‹æ’¥æ‰“165åè©é¨™å°ˆç·šè«®è©¢"
]
},
"å‡æ±‚è·è©é¨™": {
"description": "ä»¥è™›å‡å·¥ä½œæ©Ÿæœƒç‚ºèª˜é¤Œï¼Œé¨™å–å€‹äººéŠ€è¡Œå¸³æˆ¶æˆ–é‡‘èå¡çš„è©é¨™",
"examples": [
"ä¸€åèˆè€…åœ¨ç¤¾ç¾¤å¹³å°åˆ†äº«è‡ªå·±çš„è¡¨æ¼”å½±ç‰‡ï¼Œæ”¶åˆ°ç¶²å‹ã€Œå¯§éœè‡´é ã€ç§è¨Šï¼Œè¡¨ç¤ºæ¬£è³å…¶èˆè¹ˆé¢¨æ ¼ï¼Œé‚€è«‹åƒåŠ ç§äººèšæœƒè¡¨æ¼”ã€‚é›™æ–¹è½‰è‡³LINEæºé€šï¼Œå°æ–¹ä»¥æ”¯ä»˜è¨‚é‡‘ç‚ºç”±ï¼Œè¦æ±‚æä¾›éŠ€è¡Œå¸³æˆ¶ã€‚æ­¤å¾Œï¼Œå°æ–¹å¤±è¯ï¼Œä½†å—å®³è€…å¸³æˆ¶é™¸çºŒæœ‰ä¸æ˜æ¬¾é …åŒ¯å…¥ã€‚æœ€çµ‚è¢«å‘ŠçŸ¥å¸³æˆ¶å·²è¢«åˆ—ç‚ºè­¦ç¤ºå¸³æˆ¶ï¼Œè­¦æ–¹èª¿æŸ¥ç™¼ç¾é€™äº›æ¬¾é …æ¶‰åŠå…¶ä»–è©é¨™æ¡ˆä»¶ï¼Œå—å®³è€…çš„å¸³æˆ¶è¢«ç”¨ä¾†æ´—éŒ¢ã€‚"
],
"sop": [
"ä¸è¦æä¾›éŠ€è¡Œå¸³æˆ¶è³‡æ–™çµ¦é™Œç”Ÿäºº",
"å¸³æˆ¶æœ‰ä¸æ˜åŒ¯å…¥æ¬¾é …ï¼Œè«‹è¯ç¹«é–‹æˆ¶éŠ€è¡Œä¸¦ç«‹å³å ±è­¦",
"å°æ–¼é«˜è–ªã€ä½é–€æª»çš„å·¥ä½œé‚€ç´„ä¿æŒè­¦è¦º",
"ä¸è¦è¼•æ˜“ç›¸ä¿¡å¯ä»¥å¿«é€Ÿè³ºéŒ¢çš„å·¥ä½œæ©Ÿæœƒ",
"ä¸è¦å¯„å‡ºé‡‘èå¡ã€ææ¬¾å¡æˆ–å­˜ç°¿çµ¦ä»–äºº",
"ä¸è¦å°‡å¡ç‰‡æ”¾ç½®æ–¼æŒ‡å®šç½®ç‰©æ«ƒã€éƒµç®±ä¾›ä»–äººæ”¶å–",
"é¿å…å”åŠ©ä»–äººæ“ä½œATMæˆ–ç¶²è·¯éŠ€è¡Œ",
"å·¥ä½œå…§å®¹è‹¥æ¶‰åŠé‡‘èäº¤æ˜“æˆ–è½‰å¸³ï¼Œå¤šåŠæ˜¯è©é¨™",
"å¾µæ‰ç®¡é“æ‡‰ä»¥æ­£è¦æ±‚è·å¹³å°ç‚ºä¸»",
"æœ‰ä»»ä½•ç–‘å•ï¼Œè«‹æ’¥æ‰“165åè©é¨™å°ˆç·šè«®è©¢"
]
},
"å‡æª¢è­¦è©é¨™": {
"description": "å†’å……åŸ·æ³•æ©Ÿé—œäººå“¡ï¼ˆè­¦å¯Ÿã€æª¢å¯Ÿå®˜ã€æ³•å®˜ç­‰ï¼‰é€²è¡Œè©é¨™ï¼Œä»¥ã€Œè­‰ä»¶é­å†’ç”¨ã€ã€ã€Œæ¶‰åŠåˆ‘æ¡ˆã€ç­‰è—‰å£ï¼Œèª˜å°è¢«å®³äººæä¾›é‡‘èè³‡è¨Šæˆ–åŒ¯æ¬¾",
"examples": [
"æ°‘çœ¾å°åŠ‰æ¥ç²å‡å†’é¦¬å•é†«é™¢äººå“¡é›»è©±ï¼Œå°æ–¹ä½¯ç¨±æœ‰äººæŒå°åŠ‰è­‰ä»¶ä»£é ˜ç®¡åˆ¶è—¥å“ï¼Œéœ€è¦æ ¸å¯¦èº«åˆ†ã€‚ç•¶å°åŠ‰å¦èªæœ‰å§”è¨—ä»£é ˜è—¥å“ä¸€äº‹ï¼Œå‡å†’é†«é™¢äººå“¡éš¨å³å‘ŠçŸ¥å°‡ç”±æª¢è­¦æ¥æ‰‹ã€‚éš¨å¾Œå‡å†’è­¦å¯Ÿã€æª¢å¯Ÿå®˜æ¥é€£ä¾†é›»ï¼Œç¾…ç¹”ç½ªåå¾Œï¼Œè¦æ±‚å°åŠ‰äº¤ä»˜é‡‘èå¡èˆ‡å¸³æˆ¶è³‡æ–™ã€‚å¹¸å¥½å°åŠ‰ä¿æŒè­¦è¦ºï¼Œäº‹å¾Œç«‹å³é€šå ±165æª¢èˆ‰ã€‚æ­¤æ¡ˆèˆ‡è¿‘æœŸé†«ç™‚é™¢æ‰€ç—…æ‚£å€‹è³‡å¤–æ´©æœ‰é—œï¼Œè©é¨™é›†åœ˜å¯èƒ½å–å¾—é€™äº›å¤–æ´©å€‹è³‡ï¼Œé€²è¡Œç²¾æº–è©é¨™ã€‚"
],
"sop": [
"æª¢è­¦ä¸æœƒç”¨é›»è©±é€šçŸ¥æ¶‰æ¡ˆï¼Œæœƒä»¥å…¬æ–‡å‚³å–š",
"æª¢è­¦ä¸æœƒè¦æ±‚æä¾›é‡‘èå¸³æˆ¶ã€å­˜æ‘ºæˆ–é‡‘èå¡",
"æª¢è­¦ä¸æœƒè¦æ±‚è§£é™¤åˆ†æœŸä»˜æ¬¾",
"æª¢è­¦ä¸æœƒç›£ç®¡éŠ€è¡Œå¸³æˆ¶æˆ–æ“ä½œATM",
"æª¢è­¦ä¸æœƒè¦æ±‚äº¤ä»˜ç¾é‡‘æˆ–åŒ¯æ¬¾",
"æª¢è­¦ä¸æœƒç”¨LINEè£½ä½œç­†éŒ„",
"æª¢è­¦ä¸æœƒä»¥é›»è©±å‚³é€å…¬æ–‡",
"æ¥åˆ°å¯ç–‘ä¾†é›»ï¼Œæ›æ–·ä¸¦æ’¥æ‰“165åè©é¨™å°ˆç·šæŸ¥è­‰",
"å°ä¾†é›»é¡¯ç¤º110æˆ–æ´¾å‡ºæ‰€é›»è©±ä¿æŒæ‡·ç–‘ï¼Œé€™äº›è™Ÿç¢¼å¯èƒ½è¢«å½é€ ",
"é†«é™¢çµ•ä¸æœƒè½‰æ¥æª¢è­¦è™•ç†å†’ç”¨èº«åˆ†æˆ–ä»£é ˜è—¥å“äº‹å®œ",
"ä¸é€éœ²å€‹äººè³‡è¨Šï¼Œä¸é»æ“Šä¸æ˜é€£çµï¼Œä¸è¼•æ˜“åŒ¯æ¬¾"
]
},
"é‡‘èå¸³æˆ¶è©é¨™": {
"description": "é€éå„ç¨®æ‰‹æ®µé¨™å–æ°‘çœ¾é‡‘èå¸³æˆ¶ã€é‡‘èå¡æˆ–ç¶²è·¯éŠ€è¡Œå¯†ç¢¼ï¼Œç”¨æ–¼éæ³•äº¤æ˜“æˆ–æ´—éŒ¢",
"examples": [
"å—å®³è€…çœ‹åˆ°ä¸€å‰‡ã€Œå‡ºç§Ÿé‡‘èå¸³æˆ¶ï¼Œè¼•é¬†è³ºç§Ÿé‡‘ã€çš„å»£å‘Šå¾Œå¿ƒå‹•ï¼Œèˆ‡å°æ–¹è¯ç¹«ä¸¦æŒ‰æŒ‡ç¤ºå°‡ææ¬¾å¡å’Œå¸³æˆ¶è³‡è¨Šæ”¾ç½®åœ¨æŒ‡å®šçš„è®Šé›»ç®±ä¸­ã€‚è©é¨™è€…å–å¾—å¸³æˆ¶æ§åˆ¶æ¬Šå¾Œé€²è¡Œå¤§é‡éæ³•äº¤æ˜“ï¼Œå°è‡´å¸³æˆ¶è¢«éŠ€è¡Œå‡çµï¼Œå—å®³è€…ä¸åƒ…æœªå¾—åˆ°æ‰¿è«¾çš„ç§Ÿé‡‘ï¼Œé‚„é¢è‡¨æ³•å¾‹è¿½è¨´é¢¨éšªã€‚"
],
"sop": [
"å¸³æˆ¶ã€ææ¬¾å¡åŠå¯†ç¢¼æ˜¯å€‹äººè²¡å‹™å®‰å…¨æ ¸å¿ƒï¼Œåˆ‡å‹¿å‡ºç§Ÿæˆ–äº¤äºˆä»–äºº",
"ä»»ä½•è²ç¨±å‡ºç§Ÿå¸³æˆ¶å¯è³ºéŒ¢çš„å»£å‘Šï¼Œéƒ½æ˜¯è©é¨™",
"ä¸è¦å—é«˜å ±é…¬èª˜æƒ‘å‡ºå€Ÿé‡‘èå¸³æˆ¶",
"ä¸è¦è¼•ä¿¡å¯è¼•é¬†è³ºå–é¡å¤–æ”¶å…¥çš„å»£å‘Š",
"éŠ€è¡Œå®¢æœä¸æœƒè¦æ±‚æä¾›å®Œæ•´å¡è™Ÿæˆ–å¯†ç¢¼",
"ç™¼ç¾å¸³æˆ¶æœ‰ç•°å¸¸æ´»å‹•ï¼Œæ‡‰ç«‹å³è¯ç¹«éŠ€è¡Œæˆ–æ’¥æ‰“165å°ˆç·š",
"ä¸è¦åœ¨æœªç¶“ç¢ºèªçš„ç¶²ç«™è¼¸å…¥é‡‘èè³‡è¨Š",
"ä¿è­·å€‹äººé‡‘èè³‡è¨Šï¼Œä¸è¦å‘é™Œç”Ÿäººé€éœ²"
]
},
"é‡£é­šç°¡è¨Šè©é¨™": {
"description": "é€éå½è£æˆå®˜æ–¹æ©Ÿæ§‹æˆ–çŸ¥åä¼æ¥­çš„è¨Šæ¯ï¼Œèª˜å°é»æ“Šæƒ¡æ„é€£çµï¼Œé¨™å–å€‹äººè³‡æ–™æˆ–é‡‘èè³‡è¨Š",
"examples": [
"æ°‘çœ¾å°å¼µæ”¶åˆ°ä¸€å‰‡è²ç¨±ä¾†è‡ªä¸­è¯é›»ä¿¡çš„ç°¡è¨Šï¼Œå…§å®¹ç‚ºï¼šã€Œ[ä¸­è¯é›»ä¿¡]æ‚¨æ­£åœ¨ç”³è«‹çš„ç¶²è·¯æœå‹™å› å€‹è³‡é©—è­‰å¤±æ•—ï¼Œè«‹é»æ“Šä¸‹æ–¹é€£çµé‡æ–°è£œé©—...ã€ï¼Œä¸¦é™„ä¸Šä¸€ä¸²çŸ­ç¶²å€ã€‚å°å¼µä¸€æ™‚ä¸å¯Ÿé»æ“Šé€£çµï¼Œé€²å…¥ä¸€å€‹èˆ‡ä¸­è¯é›»ä¿¡å®˜ç¶²æ¥µç‚ºç›¸ä¼¼çš„é é¢ï¼Œä¸¦ä¾ç…§æŒ‡ç¤ºè¼¸å…¥äº†èº«åˆ†è­‰å­—è™Ÿã€éŠ€è¡Œå¸³è™ŸåŠä¿¡ç”¨å¡è³‡è¨Šã€‚ä¸ä¹…å¾Œï¼Œä»–ä¾¿æ”¶åˆ°éŠ€è¡Œé€šçŸ¥æœ‰å¤šç­†ä¸æ˜æ¶ˆè²»ï¼Œæ‰é©šè¦ºå—é¨™ã€‚"
],
"sop": [
"æ”¶åˆ°ä»»ä½•è¦æ±‚é»æ“Šé€£çµä¸¦è¼¸å…¥å€‹äººè³‡æ–™çš„ç°¡è¨Šï¼Œå‹™å¿…æé«˜è­¦è¦ºã€‚",
"ä¸è¦é»æ“Šä¾†æºä¸æ˜çš„ç°¡è¨Šé€£çµã€‚",
"å®˜æ–¹æ©Ÿæ§‹ä¸æœƒé€éç°¡è¨Šè¦æ±‚æ°‘çœ¾è¼¸å…¥æ•æ„Ÿå€‹è³‡æˆ–éŠ€è¡Œå¸³æˆ¶è³‡è¨Šã€‚",
"ä»”ç´°æª¢æŸ¥ç¶²å€æ˜¯å¦ç‚ºå®˜æ–¹ç¶²å€ï¼Œé‡£é­šç¶²ç«™é€šå¸¸æœƒæœ‰ç´°å¾®å·®ç•°ã€‚",
"é–‹å•Ÿç°¡è¨Šå¯¦è¯åˆ¶ï¼Œä¸¦ç¢ºèªç™¼é€è™Ÿç¢¼æ˜¯å¦ç‚ºå®˜æ–¹è™Ÿç¢¼ã€‚",
"è‹¥ä¸ç¢ºå®šç°¡è¨ŠçœŸå½ï¼Œæ‡‰ç›´æ¥å‘å®˜æ–¹å®¢æœæŸ¥è­‰ï¼Œè€Œéé»æ“Šç°¡è¨Šä¸­é€£çµã€‚",
"å®‰è£é˜²æ¯’è»Ÿé«”ä¸¦å®šæœŸæ›´æ–°ï¼Œå¯å”åŠ©åµæ¸¬æƒ¡æ„ç¶²ç«™ã€‚",
"æ•™è‚²å®¶ä¸­é•·è¼©è­˜åˆ¥é‡£é­šç°¡è¨Šçš„æŠ€å·§ã€‚",
"è‹¥å·²é»æ“Šä¸¦è¼¸å…¥è³‡æ–™ï¼Œæ‡‰ç«‹å³è¯ç¹«éŠ€è¡Œåœå¡ä¸¦å ±è­¦è™•ç†ã€‚"
]
},
"é»æ•¸è³¼è²·è©é¨™": {
"description": "è¦æ±‚è¢«å®³äººè³¼è²·éŠæˆ²é»æ•¸ã€ç¦®å“å¡ç­‰ï¼Œä¸¦æä¾›å…¶åºè™Ÿæˆ–å¯†ç¢¼çš„è©é¨™æ‰‹æ³•",
"examples": [
"ğŸ® è™›æ“¬å¯¶ç‰©æ›ç¾é‡‘çš„é¨™å±€ ğŸ®\n\næˆ‘åœ¨ã€Šç†±è¡€æ±Ÿæ¹–ã€‹éŠæˆ²æ‰“åˆ°äº†ä¸€ä»¶ç›¸ç•¶ç¨€æœ‰ç½•è¦‹çš„å¯¶ç‰©ï¼Œåœ¨éŠæˆ²åœˆå…§å¸å¼•äº†ä¸å°‘ç©å®¶çš„æ³¨æ„ï¼Œæœ‰ä¸€ä½éŠæˆ²æš±ç¨±ã€Œæ—åŒ—å°èˆã€çš„å¥½å‹ç§è¨Šæˆ‘ï¼Œèªªä»–å¾ˆæƒ³æ”¶è³¼æˆ‘çš„å¯¶ç‰©ã€‚ä»–è¡¨ç¤ºå¯¶ç‰©å°ä»–çµ„è£è£å‚™éå¸¸é‡è¦ï¼Œé¡˜æ„ä»¥8,500å…ƒåƒ¹æ ¼è³¼å…¥ã€‚å› ç‚ºä¹‹å‰æˆ‘å€‘æ›¾çµ„éšŠèŠéå¥½å¹¾æ¬¡ï¼Œå°æ–¹çœ‹èµ·ä¾†ä¸åƒé¨™å­ï¼Œæˆ‘ä¾¿ç­”æ‡‰å‡ºå”®å¯¶ç‰©ã€‚\n\nä¸éï¼Œå°æ–¹èªªæœˆåº•æ‰é ˜è–ªæ°´ï¼Œç„¡æ³•é¦¬ä¸Šä»˜æ¬¾ï¼Œèƒ½å¦å…ˆäº¤ä»˜å¯¶ç‰©è®“ä»–æå‰å¢å¼·è£å‚™ï¼Œç­‰åˆ°æœˆåº•é ˜è–ªå¾Œå†åŒ¯æ¬¾ã€‚æˆ‘å¿ƒæƒ³ï¼Œå¤§å®¶éƒ½æ˜¯åŒä¸€å€‹éŠæˆ²å…¬æœƒçš„è€ç©å®¶ï¼Œæœ‰ä¸€å®šçš„ä¿¡ä»»åŸºç¤ï¼Œæ²’å¤šæƒ³å°±æŠŠå¯¶ç‰©äº¤çµ¦äº†ä»–ã€‚\n\nä¹‹å¾Œï¼Œæˆ‘å’Œã€Œæ—åŒ—å°èˆã€ä¾èˆŠæ¯å¤©åœ¨éŠæˆ²ä¸­äº’å‹•ï¼Œä»–èª‡è®šæˆ‘é‚£ä»¶å¯¶ç‰©å¹«äº†ä»–å¤§å¿™ï¼Œè®“ä»–åœ¨éŠæˆ²ä¸­å¦‚è™æ·»ç¿¼ã€‚ç„¶è€Œï¼Œåˆ°äº†ç´„å®šä»˜æ¬¾æ—¥æœŸï¼Œæˆ‘å»å§‹çµ‚æ²’æ”¶åˆ°ä»–çš„åŒ¯æ¬¾æ¶ˆæ¯ã€‚å‰›é–‹å§‹ï¼Œæˆ‘æé†’ä»–å¹¾æ¬¡ï¼Œä»–ç¸½æ˜¯å„ç¨®ç†ç”±æ¨è„«ï¼Œè¦å˜›è–ªæ°´å»¶é²ç™¼æ”¾ã€è¦å˜›å®¶è£¡è‡¨æ™‚æœ‰æ€¥ç”¨ï¼Œç•¢ç«Ÿæˆ‘å€‘ä¹Ÿç®—æ˜¯æœ‹å‹ï¼Œå°±å†å¯¬é™å¹¾å¤©å§ã€‚\n\næœ‰å¤©ï¼Œæˆ‘ç™¼ç¾ä»–ä¸å†å›æˆ‘è¨Šæ¯ï¼Œé€£éŠæˆ²è§’è‰²ä¹Ÿæ¶ˆå¤±å¾—ç„¡å½±ç„¡è¹¤ï¼Œæˆ‘é€™æ‰é©šè¦ºï¼Œè‡ªå·±è¢«é¨™äº†ï¼\n\nğŸ“Š è³‡æ–™ä¾†æºï¼š165æ‰“è©å„€è¡¨æ¿"
],
"sop": [
"âš ï¸ å¸¸è¦‹çŠ¯ç½ªæ‰‹æ³•åŠè©±è¡“ âš ï¸",
"1ï¸âƒ£ é›™æ–¹ç´„å®šäº¤æ˜“éŠæˆ²å¸³è™Ÿ/éŠæˆ²è£å‚™/é»æ•¸",
"2ï¸âƒ£ è¦æ±‚è‡³éŠæˆ²äº¤æ˜“å¹³å°ç¶²ç«™äº¤æ˜“ï¼Œå»è¢«ç¶²ç«™å‘ŠçŸ¥å¸³æˆ¶å‡ºéŒ¯è¦æ±‚å„²å€¼æ‰èƒ½é€€æ¬¾",
"3ï¸âƒ£ å°æ–¹ç¨±ä¸æ˜åŸå› ç„¡æ³•äº¤æ˜“å‚³é€ä¸€åœ‹éš›æ“”ä¿å¹³å°äº¤æ˜“é€£çµï¼Œå¹³å°å®¢æœç¨±å¸³æˆ¶å‡çµï¼Œéœ€å„²å€¼æ‰èƒ½è§£å‡",
"4ï¸âƒ£ è¦æ±‚åŒ¯æ¬¾è‡³æŒ‡å®šå¸³æˆ¶å„²å€¼",
"5ï¸âƒ£ è¦æ±‚è³¼è²·é»æ•¸å¡å¾Œæ‹ç…§",
"",
"ğŸ›¡ï¸ é˜²è©å°æ’‡æ­¥ ğŸ›¡ï¸",
"è™›æ“¬å¯¶ç‰©äº¤æ˜“ï¼Œæ‡‰é¸æ“‡å®˜æ–¹èªå¯çš„ç¬¬ä¸‰æ–¹å¹³å°ï¼Œæ‰æœ‰ä¿éšœã€‚",
"",
"ğŸ” è©é¨™è©±è¡“è§£æ ğŸ”",
"1. è™›æ“¬éŠæˆ²å¥½å‹è¡¨é”è³¼è²·è™›æ“¬å¯¶ç‰©æ„é¡˜",
"2. èª˜é¨™æå‰äº¤ä»˜è™›æ“¬å¯¶ç‰©ï¼Œå»è—‰æ•…å»¶é²ä»˜æ¬¾ï¼Œä¸¦å¤±è¯"
]
}
}

# åŠ è¼‰è©é¨™è©±è¡“è³‡æ–™åº« (å¯é¸)
FRAUD_TACTICS_DB = "fraud_tactics.json"
fraud_tactics_data = {}

def load_fraud_tactics():
    global fraud_tactics_data
    try:
        with open(FRAUD_TACTICS_DB, 'r', encoding='utf-8') as f:
            fraud_tactics_data = json.load(f)
        logger.info(f"æˆåŠŸå¾ {FRAUD_TACTICS_DB} åŠ è¼‰è©é¨™è©±è¡“æ•¸æ“š")
    except FileNotFoundError:
        logger.warning(f"è©é¨™è©±è¡“æ–‡ä»¶ {FRAUD_TACTICS_DB} æœªæ‰¾åˆ°ã€‚")
        fraud_tactics_data = {} # Ensure it's an empty dict if file not found
    except json.JSONDecodeError:
        logger.error(f"è§£æè©é¨™è©±è¡“æ–‡ä»¶ {FRAUD_TACTICS_DB} å¤±æ•—ã€‚")
        fraud_tactics_data = {} # Ensure it's an empty dict on parse error
    except Exception as e:
        logger.error(f"åŠ è¼‰è©é¨™è©±è¡“æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤: {e}")
        fraud_tactics_data = {}

# åˆ†æè©é¨™é¢¨éšªä¸¦è§£æçµæœ

def parse_fraud_analysis(analysis_result):
    """
    å¾ChatGPTçš„å›æ‡‰ä¸­è§£æå‡ºè©é¨™åˆ†æçµæœã€‚
    é æœŸæ ¼å¼ï¼š
    é¢¨éšªç­‰ç´šï¼š[é«˜/ä¸­/ä½/ç„¡é¢¨éšª/ä¸ç¢ºå®š]
    å¯èƒ½è©é¨™é¡å‹ï¼š[é¡å‹1, é¡å‹2, ... æˆ– ä¸é©ç”¨]
    èªªæ˜ï¼š[å…·é«”èªªæ˜]
    å»ºè­°ï¼š[å…·é«”å»ºè­°] 
    æ–°èˆˆæ‰‹æ³•ï¼š[æ˜¯/å¦] (å¯é¸)
    """
    if not analysis_result:
        return {
            "risk_level": "ä¸ç¢ºå®š",
            "fraud_type": "æœªçŸ¥",
            "explanation": "ç„¡æ³•ç²å–åˆ†æçµæœã€‚",
            "suggestions": "è«‹ç¨å¾Œå†è©¦æˆ–è¯ç¹«å®¢æœã€‚",
            "is_emerging": False
        }

    lines = analysis_result.strip().split('\n')
    result = {
        "risk_level": "ä¸ç¢ºå®š",
        "fraud_type": "æœªçŸ¥",
        "explanation": analysis_result, # Default to full analysis if parsing fails for explanation
        "suggestions": "è«‹ä¿æŒè­¦æƒ•ï¼Œå¦‚æœ‰ç–‘å•å¯è«®è©¢165åè©é¨™å°ˆç·šã€‚",
        "is_emerging": False
    }

    for line in lines:
        if line.startswith("é¢¨éšªç­‰ç´šï¼š"):
            result["risk_level"] = line.split("é¢¨éšªç­‰ç´šï¼š")[1].strip()
        elif line.startswith("å¯èƒ½è©é¨™é¡å‹ï¼š"):
            result["fraud_type"] = line.split("å¯èƒ½è©é¨™é¡å‹ï¼š")[1].strip()
            if result["fraud_type"].lower() == "ä¸é©ç”¨" or result["fraud_type"].lower() == "ç„¡":
                 result["fraud_type"] = "éè©é¨™ç›¸é—œ"
        elif line.startswith("èªªæ˜ï¼š"):
            result["explanation"] = line.split("èªªæ˜ï¼š")[1].strip()
        elif line.startswith("å»ºè­°ï¼š"):
            result["suggestions"] = line.split("å»ºè­°ï¼š")[1].strip()
        elif line.startswith("æ–°èˆˆæ‰‹æ³•ï¼š"):
            is_emerging_text = line.split("æ–°èˆˆæ‰‹æ³•ï¼š")[1].strip().lower()
            result["is_emerging"] = (is_emerging_text == "æ˜¯")

    # å¦‚æœè§£æå¾Œexplanationé‚„æ˜¯åŸå§‹å®Œæ•´è¨Šæ¯ï¼Œä¸”æœ‰å–®ç¨çš„èªªæ˜å­—æ®µï¼Œå‰‡ç”¨å–®ç¨çš„èªªæ˜
    if result["explanation"] == analysis_result and "èªªæ˜ï¼š" in analysis_result:
        pass # Keep as is, maybe it was just one line of explanation
    elif "èªªæ˜ï¼š" not in analysis_result and "å»ºè­°ï¼š" not in analysis_result : # if no specific fields, use the whole thing as explanation
         result["explanation"] = analysis_result
    
    # å¦‚æœè©é¨™é¡å‹åŒ…å«å¤šå€‹ï¼Œå–ç¬¬ä¸€å€‹ä¸»è¦çš„
    if isinstance(result["fraud_type"], str) and ',' in result["fraud_type"]:
        result["fraud_type"] = result["fraud_type"].split(',')[0].strip()
    if isinstance(result["fraud_type"], str) and 'ã€' in result["fraud_type"]:
        result["fraud_type"] = result["fraud_type"].split('ã€')[0].strip()


    return result



# ChatGPTæª¢æ¸¬è©é¨™è¨Šæ¯å‡½æ•¸
def detect_fraud_with_chatgpt(user_message, display_name="æœ‹å‹", user_id=None):
    """ä½¿ç”¨ChatGPT APIåˆ†æè¨Šæ¯æ˜¯å¦ç‚ºè©é¨™
    
    Args:
        user_message: ç”¨æˆ¶è¨Šæ¯
        display_name: ç”¨æˆ¶é¡¯ç¤ºåç¨±
        user_id: ç”¨æˆ¶IDï¼Œç”¨æ–¼ç²å–æ­·å²å°è©±
        
    Returns:
        åˆ†æçµæœçš„æ–‡æœ¬
    """
    try:
        # æ§‹å»ºåŸºæœ¬ç³»çµ±æç¤º
        system_prompt = """ä½ æ˜¯ä¸€å€‹å°ˆæ¥­çš„è©é¨™åˆ†æå°ˆå®¶ï¼Œè«‹åˆ†æä»¥ä¸‹è¨Šæ¯æ˜¯å¦å¯èƒ½æ˜¯è©é¨™ï¼š

æä¾›åˆ†æçµæœæ™‚ï¼Œè«‹ä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼ˆç”¨ä¸­æ–‡å›ç­”ï¼‰ï¼š
{
  "risk_level": "[é«˜/ä¸­/ä½/ç„¡é¢¨éšª/ä¸ç¢ºå®š]",
  "fraud_type": "[è©é¨™é¡å‹ï¼Œå¦‚ï¼šå‡æŠ•è³‡/å‡äº¤å‹/å‡è³¼ç‰©/å‡å®¢æœ/ä¸æ˜¯è©é¨™]",
  "explanation": "[ç°¡æ˜æ‰¼è¦çš„åˆ†æèªªæ˜ï¼Œä¸è¶…é100å­—]",
  "suggestions": "[å…·é«”å»ºè­°ï¼Œä¸è¶…é100å­—]",
  "is_emerging": "[true/falseï¼Œæ˜¯å¦ç‚ºæ–°å‹æ…‹è©é¨™]"
}

åªéœ€å›å‚³JSONæ ¼å¼ï¼Œä¸è¦å¤šé¤˜çš„èªªæ˜æˆ–å‰å¾Œç¶´ã€‚å¦‚æœç„¡æ³•ç¢ºå®šæ˜¯è©é¨™ï¼Œè«‹è¨­ç½®é¢¨éšªç­‰ç´šç‚ºã€Œä¸ç¢ºå®šã€ã€‚"""

        # åˆå§‹åŒ–æ¶ˆæ¯åˆ—è¡¨
        messages = [
            {"role": "system", "content": system_prompt}
        ]
        
        # å˜—è©¦ç²å–ç”¨æˆ¶æ­·å²å°è©±ï¼Œè±å¯Œä¸Šä¸‹æ–‡
        if user_id:
            try:
                # å¾Firebaseç²å–æœ€è¿‘çš„å°è©±æ­·å²
                history = firebase_manager.get_user_recent_messages(user_id, limit=3)
                if history:
                    logger.info(f"ç²å–åˆ°ç”¨æˆ¶ {user_id} çš„æ­·å²å°è©±ï¼Œå…± {len(history)} æ¢")
                    history_prompt = """ç”¨æˆ¶æœ€è¿‘çš„å°è©±è¨˜éŒ„ï¼ˆå¾èˆŠåˆ°æ–°ï¼‰ï¼š"""
                    for i, msg in enumerate(history):
                        history_prompt += f"""{i+1}. ã€Œ{msg}ã€"""
                    messages.append({"role": "system", "content": history_prompt})
                else:
                    logger.info("è©é¨™åˆ†æç„¡æ³•ç²å–æ­·å²å°è©±ï¼Œä½¿ç”¨å–®ä¸€è¨Šæ¯åˆ†æ")
            except Exception as e:
                logger.info("è©é¨™åˆ†æç„¡æ³•ç²å–æ­·å²å°è©±ï¼Œä½¿ç”¨å–®ä¸€è¨Šæ¯åˆ†æ")
        else:
            logger.info("æœªæä¾›user_idï¼Œè©é¨™åˆ†æå°‡ä¸ä½¿ç”¨æ­·å²è¨˜éŒ„")
        
        # æ·»åŠ è¦åˆ†æçš„ç•¶å‰è¨Šæ¯
        analysis_prompt = f"""è«‹åˆ†æé€™å‰‡è¨Šæ¯ï¼š

{user_message}

é€™æ˜¯ä¾†è‡ªã€Œ{display_name}ã€çš„è¨Šæ¯ã€‚è«‹ä¾ç…§ç³»çµ±æç¤ºçš„æ ¼å¼æä¾›JSONæ ¼å¼çš„åˆ†æçµæœã€‚"""

        messages.append({"role": "user", "content": analysis_prompt})
        
        # èª¿ç”¨ChatGPT API
        logger.info(f"ç™¼é€è©é¨™åˆ†æè«‹æ±‚çµ¦ChatGPTï¼Œå…±{len(messages)}æ¢æ¶ˆæ¯")
        response = openai.chat.completions.create(
            model=os.environ.get('OPENAI_MODEL', 'gpt-3.5-turbo'),
            messages=messages,
            temperature=0.2,  # è¼ƒä½çš„æº«åº¦ï¼Œä½¿çµæœæ›´ç¢ºå®šæ€§
            max_tokens=800
        )
        
        result = response.choices[0].message.content.strip()
        
        return result
    except Exception as e:
        logger.error(f"ChatGPT è©é¨™åˆ†æéŒ¯èª¤: {e}")
        return "æŠ±æ­‰ï¼Œæˆ‘ç¾åœ¨ç„¡æ³•åˆ†ææ‚¨çš„è¨Šæ¯ã€‚è«‹ç¨å¾Œå†è©¦ã€‚"




# --- Begin: Add these new functions for the game ---
    """
"""""    Sends a new "é¸å“ªé¡†åœŸè±†" game question to the user.
"""""
"""""    Sends a new "é¸å“ªé¡†åœŸè±†" game question to the user.
"""""
"""""    Sends a new "é¸å“ªé¡†åœŸè±†" game question to the user.
    """
    global user_game_state
    
    # å„ªå…ˆå¾é è¨­é¡Œåº«é¸å–é¡Œç›®
    if potato_game_questions:
        # å¾é¡Œåº«ä¸­éš¨æ©Ÿé¸å–ä¸€é“é¡Œç›®
        question = random.choice(potato_game_questions)
        
        # è©é¨™è¨Šæ¯ï¼ˆå‡åœŸè±†ï¼‰
        false_potato_text = question['fraud_message']
        fraud_type = question['fraud_type']
        explanation = question.get('explanation', 'é€™æ˜¯ä¸€å‰‡è©é¨™è¨Šæ¯ï¼Œè«‹ä¿æŒè­¦è¦ºã€‚')
        
        # æª¢æŸ¥é¡Œç›®æ˜¯å¦å·²æœ‰é è¨­é¸é …
        if 'options' in question and question['options'] and 'correct_option' in question:
            # ä½¿ç”¨é¡Œåº«ä¸­çš„é è¨­é¸é …
            options = question['options'].copy()
            correct_option = question['correct_option']
            
            # éš¨æ©Ÿæ‰“äº‚é¸é …é †åº
            random.shuffle(options)
            
            # é‡æ–°æ˜ å°„é¸é …ID (åŸæœ¬å¯èƒ½æ˜¯A,B,Cï¼Œç¾åœ¨æ›æˆæ–°çš„é †åº)
            option_mapping = {'A': options[0], 'B': options[1], 'C': options[2] if len(options) > 2 else None}
            
            # è¨˜éŒ„æ­£ç¢ºç­”æ¡ˆçš„æ–°ä½ç½®
            for option_id, option in option_mapping.items():
                if option and option['id'] == correct_option:
                    new_correct_option = option_id
                    break
            else:
                new_correct_option = 'A'  # é è¨­å€¼ï¼Œæ‡‰è©²ä¸æœƒç™¼ç”Ÿ
                
            # é¡¯ç¤ºé¸é …çš„æ–‡æœ¬å…§å®¹
            options_display_texts = [option['text'] for option in options if option]
            if len(options_display_texts) < 3:
                # å¦‚æœé¸é …ä¸è¶³ä¸‰å€‹ï¼Œè£œå……
                while len(options_display_texts) < 3:
                    options_display_texts.append("æ­¤é¸é …ä¸é©ç”¨")
            
            # ä¿å­˜éŠæˆ²ç‹€æ…‹ï¼ŒåŒ…æ‹¬æ–°çš„é¸é …é †åºå’Œç­”æ¡ˆä½ç½®
            user_game_state[user_id] = {
                'false_potato_original': false_potato_text,
                'fraud_type_for_explanation': fraud_type,
                'custom_explanation': explanation,
                'option_A_text': options_display_texts[0],
                'option_B_text': options_display_texts[1],
                'option_C_text': options_display_texts[2] if len(options_display_texts) > 2 else "ç„¡é¸é …C",
                'correct_option': new_correct_option,
                'using_predefined_options': True
            }
        else:
            # é¡Œç›®æ²’æœ‰é è¨­é¸é …ï¼Œä½¿ç”¨åŸä¾†çš„é‚è¼¯
            # å‰µå»ºå…©å€‹æ˜é¡¯å®‰å…¨çš„è¨Šæ¯ï¼ˆçœŸåœŸè±†ï¼‰
            true_potato_texts = [
                "æé†’æ‚¨ï¼ŒéŠ€è¡Œæ¥­å‹™äººå“¡çµ•ä¸æœƒè¦æ±‚æ‚¨æä¾›ç¶²è·¯éŠ€è¡Œå¯†ç¢¼æˆ–æ˜¯ATMæ“ä½œã€‚å¦‚æœ‰ä»»ä½•ç–‘å•è«‹æ’¥æ‰“å®˜æ–¹å®¢æœé›»è©±æŸ¥è©¢ï¼Œä¸”å‹™å¿…è¦ªè‡ªæ’¥æ‰“ï¼Œä¸è¦ä½¿ç”¨å°æ–¹æä¾›çš„é›»è©±è™Ÿç¢¼ã€‚",
                "è³¼ç‰©å‰è«‹ç¢ºèªç¶²ç«™çš„å®‰å…¨æ€§ï¼Œé¸æ“‡æœ‰httpså’Œå®‰å…¨èªè­‰çš„å®˜æ–¹ç¶²ç«™ï¼Œä¸¦é€éç¬¬ä¸‰æ–¹æ”¯ä»˜æˆ–ä¿¡ç”¨å¡ä»˜æ¬¾ä»¥ç²å¾—äº¤æ˜“ä¿éšœã€‚é‡åˆ°è¦æ±‚ç§ä¸‹äº¤æ˜“æˆ–è¦æ±‚å…ˆä»˜æ¬¾çš„è³£å®¶è«‹ç‰¹åˆ¥å°å¿ƒã€‚",
                "æ¥åˆ°é™Œç”Ÿä¾†é›»å®£ç¨±æ‚¨æ¶‰åŠåˆ‘æ¡ˆã€æ´—éŒ¢ï¼Œéœ€è¦ç›£ç®¡å¸³æˆ¶æˆ–è½‰å¸³æ“ä½œï¼Œè«‹ç«‹å³æ›æ–·ã€‚å¸æ³•å–®ä½ä¸æœƒç”¨é›»è©±è¦æ±‚æ‚¨æ“ä½œATMæˆ–éŠ€è¡Œå¸³æˆ¶ã€‚è«‹æ’¥æ‰“165åè©é¨™å°ˆç·šç¢ºèªã€‚",
                "ç¶²è·¯æŠ•è³‡å‰è«‹æŸ¥è­‰å¹³å°åˆæ³•æ€§ï¼Œä»»ä½•å®£ç¨±ã€Œä¿è­‰ç²åˆ©ã€ã€ã€Œé›¶é¢¨éšªé«˜å ±é…¬ã€çš„æŠ•è³‡éƒ½æ¥µå¯èƒ½æ˜¯è©é¨™ã€‚åˆæ³•æŠ•è³‡ç®¡é“ä¸æœƒè¦æ±‚æ‚¨å®‰è£ç‰¹å®šAPPæˆ–åŠ å…¥ç‰¹å®šé€šè¨Šè»Ÿé«”ç¾¤çµ„ã€‚",
                "ä¿è­·å€‹äººè³‡æ–™å®‰å…¨ï¼Œä¸éš¨æ„æä¾›èº«åˆ†è­‰å­—è™Ÿã€éŠ€è¡Œå¸³è™Ÿç­‰è³‡è¨Šã€‚å°æ–¹å¦‚æœ‰è¦æ±‚è³¼è²·éŠæˆ²é»æ•¸ã€ç¦®å“å¡ï¼Œä¸¦è¦æ±‚æä¾›å¡è™Ÿåºè™Ÿï¼Œå¹¾ä¹éƒ½æ˜¯è©é¨™è¡Œç‚ºã€‚"
            ]
            
            # å¾å®‰å…¨è¨Šæ¯ä¸­éš¨æ©Ÿé¸æ“‡å…©å‰‡
            selected_true_potatoes = random.sample(true_potato_texts, 2)
            
            # æ‰“äº‚ä¸‰å€‹é¸é …çš„é †åº
            options_display_texts = [false_potato_text] + selected_true_potatoes
            random.shuffle(options_display_texts)

            # æ‰¾å‡ºè©é¨™è¨Šæ¯åœ¨æ‰“äº‚å¾Œçš„ä½ç½®
            correct_option = None
            for i, text in enumerate(options_display_texts):
                if text == false_potato_text:
                    if i == 0:
                        correct_option = 'A'
                    elif i == 1:
                        correct_option = 'B'
                    else:
                        correct_option = 'C'
                    break

            user_game_state[user_id] = {
                'false_potato_original': false_potato_text,
                'fraud_type_for_explanation': fraud_type,
                'custom_explanation': explanation,
                'option_A_text': options_display_texts[0],
                'option_B_text': options_display_texts[1],
                'option_C_text': options_display_texts[2],
                'correct_option': correct_option,
                'using_predefined_options': False
            }
    else:
        # å¦‚æœæ²’æœ‰é è¨­é¡Œåº«ï¼Œå‰‡å›é€€åˆ°å¾Firebaseä¸­ç²å–
        logger.warning("ä½¿ç”¨Firebaseè³‡æ–™åº«ä½œç‚ºå‚™é¸é¡Œç›®ä¾†æº")
        report_data = firebase_manager.get_random_fraud_report_for_game()

        if not report_data:
            line_bot_api.reply_message(
                reply_token,
                TextSendMessage(text="æŠ±æ­‰ï¼Œç›®å‰é¡Œåº«è£¡æ²’æœ‰é¡Œç›®äº†ï¼Œç¨å¾Œå†è©¦è©¦å§ï¼")
            )
            return

        # è©é¨™è¨Šæ¯ï¼ˆå‡åœŸè±†ï¼‰
        false_potato_text = report_data['message']
        fraud_type = report_data['fraud_type']
        explanation = ""
        
        # å‰µå»ºå…©å€‹æ˜é¡¯å®‰å…¨çš„è¨Šæ¯ï¼ˆçœŸåœŸè±†ï¼‰
        true_potato_texts = [
            "æé†’æ‚¨ï¼ŒéŠ€è¡Œæ¥­å‹™äººå“¡çµ•ä¸æœƒè¦æ±‚æ‚¨æä¾›ç¶²è·¯éŠ€è¡Œå¯†ç¢¼æˆ–æ˜¯ATMæ“ä½œã€‚å¦‚æœ‰ä»»ä½•ç–‘å•è«‹æ’¥æ‰“å®˜æ–¹å®¢æœé›»è©±æŸ¥è©¢ï¼Œä¸”å‹™å¿…è¦ªè‡ªæ’¥æ‰“ï¼Œä¸è¦ä½¿ç”¨å°æ–¹æä¾›çš„é›»è©±è™Ÿç¢¼ã€‚",
            "è³¼ç‰©å‰è«‹ç¢ºèªç¶²ç«™çš„å®‰å…¨æ€§ï¼Œé¸æ“‡æœ‰httpså’Œå®‰å…¨èªè­‰çš„å®˜æ–¹ç¶²ç«™ï¼Œä¸¦é€éç¬¬ä¸‰æ–¹æ”¯ä»˜æˆ–ä¿¡ç”¨å¡ä»˜æ¬¾ä»¥ç²å¾—äº¤æ˜“ä¿éšœã€‚é‡åˆ°è¦æ±‚ç§ä¸‹äº¤æ˜“æˆ–è¦æ±‚å…ˆä»˜æ¬¾çš„è³£å®¶è«‹ç‰¹åˆ¥å°å¿ƒã€‚",
            "æ¥åˆ°é™Œç”Ÿä¾†é›»å®£ç¨±æ‚¨æ¶‰åŠåˆ‘æ¡ˆã€æ´—éŒ¢ï¼Œéœ€è¦ç›£ç®¡å¸³æˆ¶æˆ–è½‰å¸³æ“ä½œï¼Œè«‹ç«‹å³æ›æ–·ã€‚å¸æ³•å–®ä½ä¸æœƒç”¨é›»è©±è¦æ±‚æ‚¨æ“ä½œATMæˆ–éŠ€è¡Œå¸³æˆ¶ã€‚è«‹æ’¥æ‰“165åè©é¨™å°ˆç·šç¢ºèªã€‚",
            "ç¶²è·¯æŠ•è³‡å‰è«‹æŸ¥è­‰å¹³å°åˆæ³•æ€§ï¼Œä»»ä½•å®£ç¨±ã€Œä¿è­‰ç²åˆ©ã€ã€ã€Œé›¶é¢¨éšªé«˜å ±é…¬ã€çš„æŠ•è³‡éƒ½æ¥µå¯èƒ½æ˜¯è©é¨™ã€‚åˆæ³•æŠ•è³‡ç®¡é“ä¸æœƒè¦æ±‚æ‚¨å®‰è£ç‰¹å®šAPPæˆ–åŠ å…¥ç‰¹å®šé€šè¨Šè»Ÿé«”ç¾¤çµ„ã€‚",
            "ä¿è­·å€‹äººè³‡æ–™å®‰å…¨ï¼Œä¸éš¨æ„æä¾›èº«åˆ†è­‰å­—è™Ÿã€éŠ€è¡Œå¸³è™Ÿç­‰è³‡è¨Šã€‚å°æ–¹å¦‚æœ‰è¦æ±‚è³¼è²·éŠæˆ²é»æ•¸ã€ç¦®å“å¡ï¼Œä¸¦è¦æ±‚æä¾›å¡è™Ÿåºè™Ÿï¼Œå¹¾ä¹éƒ½æ˜¯è©é¨™è¡Œç‚ºã€‚"
        ]
        
        # å¾å®‰å…¨è¨Šæ¯ä¸­éš¨æ©Ÿé¸æ“‡å…©å‰‡
        selected_true_potatoes = random.sample(true_potato_texts, 2)
        
        # æ‰“äº‚ä¸‰å€‹é¸é …çš„é †åº
        options_display_texts = [false_potato_text] + selected_true_potatoes
        random.shuffle(options_display_texts)

        # æ‰¾å‡ºè©é¨™è¨Šæ¯åœ¨æ‰“äº‚å¾Œçš„ä½ç½®
        correct_option = None
        for i, text in enumerate(options_display_texts):
            if text == false_potato_text:
                if i == 0:
                    correct_option = 'A'
                elif i == 1:
                    correct_option = 'B'
                else:
                    correct_option = 'C'
                break

        user_game_state[user_id] = {
            'false_potato_original': false_potato_text,
            'fraud_type_for_explanation': fraud_type,
            'custom_explanation': explanation,
            'option_A_text': options_display_texts[0],
            'option_B_text': options_display_texts[1],
            'option_C_text': options_display_texts[2],
            'correct_option': correct_option,
            'using_predefined_options': False
        }

    flex_message_content = BubbleContainer(
        body=BoxComponent(
            layout='vertical',
            contents=[
                TextComponent(text='é¸å“ªé¡†åœŸè±†ï¼ŸğŸ¤”', weight='bold', size='xl', align='center', margin='md'),
                TextComponent(text='è«‹æŒ‡å‡ºä¸‹åˆ—å“ªä¸€å€‹é¸é …ã€Œæ˜¯è©é¨™è¨Šæ¯ã€ï¼ˆä¹Ÿå°±æ˜¯å‡åœŸè±†ï¼‰ï¼Ÿ', wrap=True, margin='lg', size='sm'),
                SeparatorComponent(margin='lg'),
                TextComponent(text='é¸é … A:', weight='bold', size='md', margin='lg'),
                TextComponent(text=user_game_state[user_id]['option_A_text'][:250] + '...' if len(user_game_state[user_id]['option_A_text']) > 250 else user_game_state[user_id]['option_A_text'], wrap=True, size='sm', margin='sm'),
                SeparatorComponent(margin='lg'),
                TextComponent(text='é¸é … B:', weight='bold', size='md', margin='lg'),
                TextComponent(text=user_game_state[user_id]['option_B_text'][:250] + '...' if len(user_game_state[user_id]['option_B_text']) > 250 else user_game_state[user_id]['option_B_text'], wrap=True, size='sm', margin='sm'),
                SeparatorComponent(margin='lg'),
                TextComponent(text='é¸é … C:', weight='bold', size='md', margin='lg'),
                TextComponent(text=user_game_state[user_id]['option_C_text'][:250] + '...' if len(user_game_state[user_id]['option_C_text']) > 250 else user_game_state[user_id]['option_C_text'], wrap=True, size='sm', margin='sm'),
            ]
        ),
        footer=BoxComponent(
            layout='vertical',
            spacing='sm',
            contents=[
                ButtonComponent(
                    style='primary',
                    color='#FF8C00', 
                    height='sm',
                    action=PostbackAction(label='é¸ A', data=f'action=potato_game_answer&chosen_option_id=A&uid={user_id}')
                ),
                ButtonComponent(
                    style='primary',
                    color='#FF8C00', 
                    height='sm',
                    action=PostbackAction(label='é¸ B', data=f'action=potato_game_answer&chosen_option_id=B&uid={user_id}')
                ),
                ButtonComponent(
                    style='primary',
                    color='#FF8C00', 
                    height='sm',
                    action=PostbackAction(label='é¸ C', data=f'action=potato_game_answer&chosen_option_id=C&uid={user_id}')
                )
            ]
        )
    )
    
    try:
        line_bot_api.reply_message(reply_token, FlexSendMessage(alt_text='é¸å“ªé¡†åœŸè±†ï¼Ÿå°éŠæˆ²', contents=flex_message_content))
        logger.error(f"Error sending potato game question: {e}")
        line_bot_api.reply_message(reply_token, TextSendMessage(text="æŠ±æ­‰ï¼ŒéŠæˆ²è¼‰å…¥å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚"))


def handle_potato_game_answer(user_id, reply_token, data_params):
    """
    Handles the user's answer in the "é¸å“ªé¡†åœŸè±†" game.
    """
    """
    """""
    global user_game_state
    chosen_option_id = data_params.get('chosen_option_id')

    if user_id not in user_game_state or 'false_potato_original' not in user_game_state[user_id]:
        line_bot_api.reply_message(reply_token, TextSendMessage(text="ç³Ÿç³•ï¼ŒéŠæˆ²ç‹€æ…‹å¥½åƒä¸è¦‹äº†ï¼Œéº»ç…©æ‚¨é‡æ–°é–‹å§‹éŠæˆ²å§ï¼"))
        return

    game_data = user_game_state[user_id]
    false_potato_original_text = game_data['false_potato_original']
    fraud_type_for_explanation = game_data['fraud_type_for_explanation']
    custom_explanation = game_data.get('custom_explanation', '')
    correct_option = game_data.get('correct_option')
    
    chosen_text = ""
    if chosen_option_id == 'A':
        chosen_text = game_data['option_A_text']
    elif chosen_option_id == 'B':
        chosen_text = game_data['option_B_text']
    elif chosen_option_id == 'C':
        chosen_text = game_data['option_C_text']
    else:
        line_bot_api.reply_message(reply_token, TextSendMessage(text="é¸æ“‡å‡ºéŒ¯äº†ï¼Œè«‹é‡æ–°ç©ä¸€æ¬¡å“¦ã€‚"))
        return

    reply_messages = []
    
    # ä½¿ç”¨è‡ªè¨‚è§£é‡‹æˆ–å¾é€šç”¨ç‰¹å¾µåº«ç²å–
    if custom_explanation:
        fraud_features = f"âš ï¸ è©é¨™ç‰¹å¾µèªªæ˜ï¼š\n{custom_explanation}"
    else:
        fraud_features = get_fraud_features(fraud_type_for_explanation, false_potato_original_text)
    
    explanation_intro = f"é€™å‰‡è¨Šæ¯å±¬æ–¼ã€{fraud_type_for_explanation}ã€‘é¡å‹çš„è©é¨™æ‰‹æ³•ã€‚"
    explanation_detail = f"è©é¨™è¨Šæ¯ï¼š\nã€Œ{false_potato_original_text[:180]}...ã€" 

    # åˆ¤æ–·ç”¨æˆ¶æ˜¯å¦é¸æ“‡äº†æ­£ç¢ºçš„é¸é …
    is_correct = chosen_option_id == correct_option
    
    if is_correct: 
        result_text = f"ğŸ‘ æ­å–œç­”å°äº†ï¼æ‚¨æˆåŠŸè­˜åˆ¥å‡ºè©é¨™è¨Šæ¯ï¼\n\n{explanation_intro}\n\n{explanation_detail}\n\n{fraud_features}\n\nè¨˜ä½ï¼šæé«˜è­¦è¦ºï¼Œä¿è­·è‡ªå·±å’Œè¦ªå‹çš„è³‡ç”¢å®‰å…¨ï¼"
        reply_messages.append(TextSendMessage(text=result_text))
    else: 
        result_text = f"âŒ è¦å°å¿ƒï¼æ‚¨é¸çš„ä¸æ˜¯è©é¨™è¨Šæ¯ã€‚\n\n{explanation_intro}\n\næ­£ç¢ºç­”æ¡ˆæ˜¯é¸é … {correct_option}ï¼š\nã€Œ{false_potato_original_text[:180]}...ã€\n\n{fraud_features}\n\nåˆ¥ç°å¿ƒï¼Œé€éç·´ç¿’æ‚¨æœƒè¶Šä¾†è¶Šæ“…é•·è­˜åˆ¥è©é¨™ï¼"
        reply_messages.append(TextSendMessage(text=result_text))

    quick_reply_items = QuickReply(items=[
        QuickReplyButton(action=PostbackAction(label="å†ç©ä¸€é¡Œ", data=f'action=start_potato_game&uid={user_id}')),
        QuickReplyButton(action=MessageAction(label="åˆ†æå¯ç–‘è¨Šæ¯", text="è«‹å¹«æˆ‘åˆ†æé€™å‰‡è¨Šæ¯ï¼š")),
        QuickReplyButton(action=MessageAction(label="è©é¨™é¡å‹æŸ¥è©¢", text="è©é¨™é¡å‹åˆ—è¡¨"))
    ])
    
    reply_messages.append(TextSendMessage(text="è¦ä¸è¦å†ä¾†ä¸€å±€ï¼Œæˆ–æ˜¯å˜—è©¦å…¶ä»–åŠŸèƒ½ï¼Ÿ", quick_reply=quick_reply_items))
    
    try:
        line_bot_api.reply_message(reply_token, messages=reply_messages)
        logger.error(f"Error sending potato game answer reply: {e}")

def get_fraud_features(fraud_type, fraud_message):
    """
    æ ¹æ“šè©é¨™é¡å‹æä¾›å…¸å‹è©é¨™ç‰¹å¾µèªªæ˜
    """
    common_features = """""âš ï¸ è©é¨™å¸¸è¦‹ç‰¹å¾µï¼š\n"
    
    # æ ¹æ“šè©é¨™é¡å‹æ·»åŠ ç‰¹å®šç‰¹å¾µ
    if "è³¼ç‰©" in fraud_type:
        features = [
            "1. è¦æ±‚ç§ä¸‹äº¤æ˜“æˆ–åŒ¯æ¬¾åˆ°ç§äººå¸³æˆ¶",
            "2. æ€¥è‘—æˆäº¤ï¼Œè£½é€ æ€¥è¿«æ„Ÿ",
            "3. åƒ¹æ ¼æ˜é¡¯ä½æ–¼å¸‚å ´è¡Œæƒ…",
            "4. è¦æ±‚ä½¿ç”¨éæ­£è¦æ”¯ä»˜æ–¹å¼",
            "5. è³£å®¶è³‡è¨Šæ¨¡ç³Šä¸æ¸…"
        ]
    elif "æŠ•è³‡" in fraud_type or "ç†è²¡" in fraud_type:
        features = [
            "1. ä¿è­‰ã€Œç©©è³ºä¸è³ ã€ã€ã€Œé«˜å ±é…¬ã€ä½é¢¨éšªã€",
            "2. è²ç¨±æœ‰ã€Œå…§éƒ¨è³‡è¨Šã€æˆ–ã€Œç¨å®¶æŠ•è³‡ç®¡é“ã€",
            "3. è¦æ±‚ä¸‹è¼‰ç‰¹å®šAPPæˆ–åŠ å…¥ç‰¹å®šç¾¤çµ„",
            "4. å‚¬ä¿ƒç«‹å³æŠ•è³‡ï¼Œè²ç¨±ã€Œæ©Ÿæœƒç¨ç¸±å³é€ã€",
            "5. è¦æ±‚å°‡è³‡é‡‘è½‰å…¥ã€ŒæŠ•è³‡å°ˆæˆ¶ã€"
        ]
    elif "äº¤å‹" in fraud_type:
        features = [
            "1. çŸ­æ™‚é–“å…§è¿…é€Ÿç™¼å±•è¦ªå¯†é—œä¿‚",
            "2. è‡ªç¨±é«˜ç¤¾ç¶“åœ°ä½ä½†ç„¡æ³•è¦‹é¢",
            "3. ç·¨é€ å„ç¨®ç†ç”±è«‹æ±‚é‡‘éŒ¢å”åŠ©",
            "4. è²ç¨±æœ‰ç·Šæ€¥é†«ç™‚è²»ç”¨æˆ–æ„å¤–äº‹ä»¶",
            "5. æ‹’çµ•è¦–è¨Šé€šè©±æˆ–è¦‹é¢"
        ]
    elif "æª¢è­¦" in fraud_type or "å…¬å‹™" in fraud_type:
        features = [
            "1. è²ç¨±æ‚¨æ¶‰åŠåˆ‘æ¡ˆæˆ–æ´—éŒ¢",
            "2. è¦æ±‚ç›£ç®¡æ‚¨çš„éŠ€è¡Œå¸³æˆ¶",
            "3. è¦æ±‚æ“ä½œATMæˆ–ç¶²éŠ€",
            "4. è¦æ±‚è³¼è²·é»æ•¸å¡æˆ–ç¦®å“å¡",
            "5. è­¦å‘Šä¸å¾—å‘ä»–äººé€éœ²"
        ]
    elif "ä¸­ç" in fraud_type:
        features = [
            "1. æœªåƒåŠ ä¹Ÿã€Œä¸­çã€",
            "2. è¦æ±‚æ”¯ä»˜æ‰‹çºŒè²»ã€ç¨…é‡‘æ‰èƒ½é ˜ç",
            "3. ä½¿ç”¨æ¨¡ç³Šçš„æ´»å‹•è¾¦æ³•",
            "4. é€šçŸ¥ç®¡é“å¯ç–‘ï¼ˆå¦‚ç°¡è¨Šï¼‰",
            "5. è¦æ±‚æä¾›éŠ€è¡Œå¸³è™Ÿæˆ–å€‹è³‡"
        ]
    else:
        # é€šç”¨è©é¨™ç‰¹å¾µ
        features = [
            "1. è£½é€ ç·Šæ€¥æ„Ÿèˆ‡ææ…Œ",
            "2. è¦æ±‚æä¾›æ•æ„Ÿå€‹äººè³‡æ–™",
            "3. æå‡ºä¸åˆç†æˆ–å¯ç–‘çš„è¦æ±‚",
            "4. èªæ³•éŒ¯èª¤æˆ–å¯ç–‘é€£çµ",
            "5. è¦æ±‚è½‰å¸³ã€åŒ¯æ¬¾æˆ–è³¼è²·é»æ•¸"
        ]
    
    return common_features + "\n".join(features)

# --- End: Add these new functions ---

# URLåˆ†æåŠŸèƒ½

def analyze_url(url):
    """
    åˆ†æURLçš„é¢¨éšªç­‰ç´šå’Œå®‰å…¨æ€§
    
    Args:
        url: è¦åˆ†æçš„ç¶²å€
        
    Returns:
        åˆ†æçµæœå­—å…¸
    """
    try:
        # æª¢æŸ¥æ˜¯å¦ç‚ºçŸ­ç¶²å€
        is_short_url = len(url.split('//')[-1].split('/')[0]) < 15 and any(short_domain in url.lower() for short_domain in ["bit.ly", "tinyurl", "goo.gl", "t.co", "is.gd", "etf8", "fun", "xyz", "link", "tiny", "short", "go"])
        
        original_url = url
        expanded_url = None
        
        # å¦‚æœæ˜¯çŸ­ç¶²å€ï¼Œå˜—è©¦å±•é–‹
        if is_short_url:
            expanded_url = expand_short_url(url)
            # å¦‚æœæˆåŠŸå±•é–‹ï¼Œå°‡å±•é–‹å¾Œçš„URLç”¨æ–¼åˆ†æ
            if expanded_url != url:
                url = expanded_url
                logger.info(f"ä½¿ç”¨å±•é–‹å¾Œçš„URLé€²è¡Œåˆ†æ: {url}")
        
        # é å…ˆæä¾›ä¸€äº›åŸºæœ¬çš„å®‰å…¨ç‰¹å¾µè©•ä¼°
        https_secure = url.startswith("https://")
        has_suspicious_params = "?" in url and any(param in url.lower() for param in ["redirect", "url=", "goto=", "return="])
        domain = url.split("//")[-1].split("/")[0].lower()
        
        # åˆ¤æ–·æ˜¯å¦ç‚ºæ”¿åºœç¶²ç«™
        is_gov_site = ".gov" in domain
        is_official_site = any(org in domain for org in [".edu", ".org", ".gov", ".mil"])
        
        # ä½¿ç”¨ChatGPTé€²è¡ŒURLåˆ†æ
        system_prompt = """ä½ æ˜¯ä¸€ä½ç¶²è·¯å®‰å…¨å°ˆå®¶ï¼Œè«‹ç°¡æ˜æ‰¼è¦åœ°åˆ†æä»¥ä¸‹URLçš„é¢¨éšªï¼š
        
è«‹ä¾ç…§ä»¥ä¸‹æ ¼å¼å›è¦†ï¼ˆç”¨ä¸­æ–‡å›ç­”ï¼Œä½¿ç”¨ç°¡å–®æ˜“æ‡‚çš„èªè¨€ï¼Œé©åˆéæŠ€è¡“äººå£«ç†è§£ï¼‰ï¼š
é¢¨éšªç­‰ç´šï¼š[é«˜/ä¸­/ä½]
åŸå› ï¼š[3-4é»ç°¡çŸ­èªªæ˜é€™å€‹ç¶²å€å®‰å…¨æˆ–æœ‰é¢¨éšªçš„åŸå› ]
å¯èƒ½ç”¨é€”ï¼š[2-3é»ç°¡çŸ­èªªæ˜é€™å€‹ç¶²ç«™å¯èƒ½çš„ç”¨é€”]
å»ºè­°ï¼š[2-3é»ç°¡çŸ­çš„å®‰å…¨å»ºè­°]

æ³¨æ„ï¼š
1. è«‹ä½¿ç”¨ç°¡å–®çš„èªè¨€ï¼Œé¿å…æŠ€è¡“è¡“èª
2. è«‹ç”¨æ¢åˆ—å¼å›ç­”ï¼Œæ¯é»ä¸è¶…é20å­—
3. æ•´é«”å›ç­”ç°¡çŸ­ç²¾ç°¡ï¼Œé‡é»æ˜¯è®“ä¸€èˆ¬ç”¨æˆ¶å®¹æ˜“ç†è§£
4. è«‹ä¸è¦è¿”å›JSONæ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨ç´”æ–‡æœ¬å›æ‡‰
5. ä¸è¦ä½¿ç”¨markdownæ ¼å¼

åˆ†æè€ƒæ…®å› ç´ ï¼š
- ç¶²åŸŸæ˜¯æ”¿åºœæˆ–çŸ¥åçµ„ç¹”å—ï¼Ÿ
- æœ‰ä½¿ç”¨HTTPSå—ï¼Ÿ
- URLçµæ§‹æ˜¯å¦åˆç†ï¼Ÿ
- ç¶²ç«™çš„å¯èƒ½ç”¨é€”ï¼Ÿ
    """

        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": f"è«‹åˆ†æé€™å€‹URL: {url}"}
        ]
        
        logger.info(f"ç™¼é€URLåˆ†æè«‹æ±‚çµ¦ChatGPT: {url}")
        response = openai.chat.completions.create(
            model=os.environ.get('OPENAI_MODEL', 'gpt-3.5-turbo'),
            messages=messages,
            temperature=0.2,
            max_tokens=500  # æ¸›å°‘tokenä»¥ç²å–æ›´ç°¡æ½”çš„å›æ‡‰
        )
        
        result = response.choices[0].message.content.strip()
        logger.info(f"ChatGPT URLåˆ†æå›æ‡‰: {result}")
        
        # æª¢æŸ¥çµæœæ˜¯å¦ç‚º JSON æ ¼å¼ï¼Œä¸¦å˜—è©¦æå–å…§å®¹
        json_start = result.find('{')
        json_end = result.rfind('}')
        
        # å¦‚æœç™¼ç¾ JSON çµæ§‹ï¼Œå˜—è©¦æå–ä¸¦è§£æ
        if json_start >= 0 and json_end > json_start:
            try:
                json_part = result[json_start:json_end+1]
                parsed_json = json.loads(json_part)
                logger.info(f"å¾å›æ‡‰ä¸­æå–JSON: {json_part}")
                
                # å°‡JSONå…§å®¹è½‰æ›ç‚ºæ¨™æº–åˆ†æçµæœæ ¼å¼
                extracted_result = {}
                
                # æå–å„å€‹å­—æ®µ
                if "risk_level" in parsed_json:
                    extracted_result["risk_level"] = parsed_json["risk_level"]
                
                # æå–æˆ–çµ„åˆåˆ†æåŸå› 
                if "explanation" in parsed_json:
                    extracted_result["reason"] = parsed_json["explanation"]
                elif "reason" in parsed_json:
                    extracted_result["reason"] = parsed_json["reason"]
                    
                # æå–æˆ–çµ„åˆç”¨é€”ä¿¡æ¯
                if "purpose" in parsed_json:
                    extracted_result["purpose"] = parsed_json["purpose"]
                else:
                    # å¦‚æœæ²’æœ‰ç”¨é€”å­—æ®µï¼Œå˜—è©¦å¾å…¶ä»–å­—æ®µæå–ç›¸é—œä¿¡æ¯
                    extracted_result["purpose"] = "- æ ¹æ“šç¶²å€åˆ†æç¢ºå®šå¯èƒ½ç”¨é€”\n- è«‹è¬¹æ…åˆ¤æ–·ç¶²ç«™çœŸå¯¦æ„åœ–"
                
                # æå–æˆ–çµ„åˆå»ºè­°
                if "suggestions" in parsed_json:
                    extracted_result["suggestion"] = parsed_json["suggestions"]
                elif "suggestion" in parsed_json:
                    extracted_result["suggestion"] = parsed_json["suggestion"]
                
                # è¨˜éŒ„æå–çš„çµæœ
                logger.info(f"å¾JSONæå–çš„åˆ†æçµæœ: {extracted_result}")
                
                # æ›´æ–°çµæœï¼Œä½†ä¿ç•™åŸå§‹ JSON ä»¥ä¾›åƒè€ƒ
                result = "é¢¨éšªç­‰ç´šï¼š" + extracted_result.get("risk_level", "ä¸ç¢ºå®š") + "\n"
                if "reason" in extracted_result and extracted_result["reason"]:
                    result += "åŸå› ï¼š" + extracted_result["reason"] + "\n"
                if "purpose" in extracted_result and extracted_result["purpose"]:
                    result += "å¯èƒ½ç”¨é€”ï¼š" + extracted_result["purpose"] + "\n"
                if "suggestion" in extracted_result and extracted_result["suggestion"]:
                    result += "å»ºè­°ï¼š" + extracted_result["suggestion"]
                
                logger.info(f"é‡æ–°æ ¼å¼åŒ–å¾Œçš„åˆ†æçµæœ: {result}")
            except json.JSONDecodeError as e:
                logger.warning(f"JSONè§£æå¤±æ•—ï¼Œå°‡ä½¿ç”¨åŸå§‹æ–‡æœ¬: {e}")
        
        # è§£æåˆ†æçµæœ - é¦–å…ˆè¨­ç½®é è¨­å€¼
        if is_gov_site:
            default_risk = "ä½"
            default_reason = f"1. ç¶²åŸŸåˆ†æï¼šè©²URLå±¬æ–¼æ”¿åºœç¶²ç«™\n2. ä¸€èˆ¬æ”¿åºœç¶²ç«™å¯ä¿¡åº¦é«˜\n3. {'ä½¿ç”¨' if https_secure else 'æœªä½¿ç”¨'}HTTPSå®‰å…¨é€£ç·š"
            default_purpose = "- æä¾›æ”¿åºœæœå‹™å’Œè³‡è¨Š\n- å®˜æ–¹æ–°èæˆ–å…¬å‘Šå¹³å°"
            default_suggestion = "1. ç¢ºèªç¶²å€æ˜¯å¦æ­£ç¢º\n2. ä¸è¦éš¨æ„é»æ“Šé é¢ä¸­çš„å…¶ä»–é€£çµ"
        elif is_official_site:
            default_risk = "ä½"
            default_reason = f"1. ç¶²åŸŸåˆ†æï¼šè©²URLä½¿ç”¨æ­£è¦çµ„ç¹”ç¶²åŸŸ\n2. æ­¤é¡ç¶²ç«™é€šå¸¸å¯ä¿¡åº¦é«˜\n3. {'ä½¿ç”¨' if https_secure else 'æœªä½¿ç”¨'}HTTPSå®‰å…¨é€£ç·š"
            default_purpose = "- æä¾›çµ„ç¹”æœå‹™å’Œè³‡è¨Š\n- å®˜æ–¹è³‡è¨Šå¹³å°"
            default_suggestion = "1. ç¢ºèªç¶²å€æ˜¯å¦æ­£ç¢º\n2. ä¸è¦éš¨æ„æä¾›å€‹äººè³‡æ–™"
        else:
            default_risk = "ä¸­" if https_secure else "é«˜"
            default_reason = f"1. ç¶²åŸŸåˆ†æï¼šéå®˜æ–¹çµ„ç¹”ç¶²åŸŸ\n2. {'ä½¿ç”¨' if https_secure else 'æœªä½¿ç”¨'}HTTPSå®‰å…¨é€£ç·š\n3. {'æœ‰' if has_suspicious_params else 'ç„¡'}å¯ç–‘åƒæ•¸"
            default_purpose = "- å¯èƒ½æ˜¯å€‹äººæˆ–å•†æ¥­ç¶²ç«™\n- åŠŸèƒ½éœ€é€²ä¸€æ­¥ç¢ºèª"
            default_suggestion = "1. ä¸å»ºè­°æä¾›æ•æ„Ÿè³‡è¨Š\n2. é¿å…ä¸‹è¼‰æª”æ¡ˆæˆ–è»Ÿé«”"
        
        # ä½¿ç”¨æ­£å‰‡è¡¨é”å¼è§£æChatGPTå›æ‡‰
        analysis = {
            "risk_level": default_risk,
            "reason": default_reason,
            "purpose": default_purpose,
            "suggestion": default_suggestion
        }
        
        # è§£æChatGPTçš„å›æ‡‰
        lines = result.split('\n')
        current_section = None
        section_content = []
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            if line.startswith("é¢¨éšªç­‰ç´šï¼š"):
                analysis["risk_level"] = line.replace("é¢¨éšªç­‰ç´šï¼š", "").strip()
                current_section = None
            elif line.startswith("åŸå› ï¼š"):
                current_section = "reason"
                content = line.replace("åŸå› ï¼š", "").strip()
                if content:
                    section_content.append(content)
            elif line.startswith("å¯èƒ½ç”¨é€”ï¼š"):
                if current_section == "reason" and section_content:
                    analysis["reason"] = "\n".join(section_content)
                current_section = "purpose"
                section_content = []
                content = line.replace("å¯èƒ½ç”¨é€”ï¼š", "").strip()
                if content:
                    section_content.append(content)
            elif line.startswith("å»ºè­°ï¼š"):
                if current_section == "purpose" and section_content:
                    analysis["purpose"] = "\n".join(section_content)
                current_section = "suggestion"
                section_content = []
                content = line.replace("å»ºè­°ï¼š", "").strip()
                if content:
                    section_content.append(content)
            elif current_section:
                section_content.append(line)
        
        # è™•ç†æœ€å¾Œä¸€å€‹å€æ®µçš„å…§å®¹
        if current_section == "suggestion" and section_content:
            analysis["suggestion"] = "\n".join(section_content)
        
        # æª¢æŸ¥ä¸¦ä½¿ç”¨é è¨­å€¼å¡«å……ç©ºç™½å€åŸŸ
        if not analysis["reason"] or analysis["reason"] == "":
            analysis["reason"] = default_reason
            
        if not analysis["purpose"] or analysis["purpose"] == "":
            analysis["purpose"] = default_purpose
            
        if not analysis["suggestion"] or analysis["suggestion"] == "":
            analysis["suggestion"] = default_suggestion
            
        # å¦‚æœæ²’æœ‰æˆåŠŸè§£æï¼Œå‰‡ä¿å­˜åŸå§‹å›æ‡‰
        if analysis["risk_level"] == "ä¸ç¢ºå®š" and "raw_response" not in analysis:
            analysis["raw_response"] = result
            
        # æª¢æŸ¥æ˜¯å¦æœ‰æœªè™•ç†çš„JSONå­—ç¬¦ä¸²
        for key, value in analysis.items():
            if isinstance(value, str) and (value.startswith('{') and value.endswith('}')):
                try:
                    # å˜—è©¦è§£æJSON
                    parsed_json = json.loads(value)
                    # å¦‚æœæˆåŠŸè§£æï¼Œæå–æ–‡æœ¬
                    if isinstance(parsed_json, dict):
                        if "explanation" in parsed_json:
                            analysis[key] = parsed_json.get("explanation", "ç„¡æ³•è§£æå…§å®¹")
                        elif "suggestions" in parsed_json:
                            analysis[key] = parsed_json.get("suggestions", "ç„¡å»ºè­°")
                        else:
                            # å–ç¬¬ä¸€å€‹æœ‰å€¼çš„å­—æ®µ
                            for json_key, json_value in parsed_json.items():
                                if json_value and isinstance(json_value, str):
                                    analysis[key] = json_value
                                    break
                except json.JSONDecodeError:
                    # å¦‚æœä¸æ˜¯æœ‰æ•ˆçš„JSONï¼Œä¿ç•™åŸå§‹å€¼ä½†ç§»é™¤èŠ±æ‹¬è™Ÿ
                    analysis[key] = value[1:-1].replace('"', '').replace(',', '\n')
                    
        # ç¢ºä¿æ‰€æœ‰å€¼éƒ½æ˜¯å­—ç¬¦ä¸²ä¸”ä¸æ˜¯JSONæ ¼å¼
        for key, value in analysis.items():
            if value and isinstance(value, str):
                # å¦‚æœå€¼çœ‹èµ·ä¾†åƒJSONå­—ç¬¦ä¸²ï¼Œå‰‡é€²è¡Œæ¸…ç†
                if (value.startswith('{') and value.endswith('}')) or (value.startswith('[') and value.endswith(']')):
                    # å˜—è©¦æå–ç´”æ–‡æœ¬
                    cleaned_value = value
                    cleaned_value = cleaned_value.replace('{', '').replace('}', '')
                    cleaned_value = cleaned_value.replace('"', '').replace(',', '\n')
                    analysis[key] = cleaned_value
        
        # æ·»åŠ çŸ­ç¶²å€ä¿¡æ¯
        if is_short_url:
            # å¦‚æœæ˜¯çŸ­ç¶²å€ï¼Œæ·»åŠ ç›¸é—œä¿¡æ¯
            short_url_warning = "âš ï¸ é€™å€‹ç¶²å€æ˜¯çŸ­ç¶²å€æˆ–è½‰å€æœå‹™ï¼Œé€™é¡ç¶²å€å¯èƒ½éš±è—äº†çœŸå¯¦ç›®çš„åœ°ï¼Œå»ºè­°è¬¹æ…ä½¿ç”¨ã€‚"
            analysis["short_url_warning"] = short_url_warning
            
            # å¦‚æœæˆåŠŸå±•é–‹çŸ­ç¶²å€ï¼Œæ·»åŠ å±•é–‹ä¿¡æ¯
            if expanded_url and expanded_url != original_url:
                analysis["original_url"] = original_url
                analysis["expanded_url"] = expanded_url
                
                # åœ¨åˆ†æåŸå› ä¸­æ·»åŠ å±•é–‹å¾Œçš„URLä¿¡æ¯
                if "reason" in analysis:
                    analysis["reason"] = f"- é€™æ˜¯çŸ­ç¶²å€ï¼Œå·²å±•é–‹ç‚º:{expanded_url}\n" + str(analysis["reason"])
                
                    # å¦‚æœæ˜¯çŸ­ç¶²å€ï¼Œæé«˜é¢¨éšªç­‰ç´š
                    if analysis_result.get("risk_level", "") == "ä½":
                        analysis_result["risk_level"] = "ä¸­"
                    elif analysis_result.get("risk_level", "") == "ä¸­":
                        analysis_result["risk_level"] = "é«˜"
                    
                    # æ·»åŠ çŸ­ç¶²å€è­¦å‘Š
                    short_url_warning = "âš ï¸ é€™å€‹ç¶²å€ä¼¼ä¹æ˜¯çŸ­ç¶²å€æˆ–è½‰å€æœå‹™ï¼Œé€™é¡ç¶²å€å¯èƒ½éš±è—äº†çœŸå¯¦ç›®çš„åœ°ï¼Œå»ºè­°è¬¹æ…ä½¿ç”¨ã€‚"
                    analysis_result["short_url_warning"] = short_url_warning
                    
                    # åœ¨åˆ†æåŸå› ä¸­æ·»åŠ çŸ­ç¶²å€è­¦å‘Š
                    if "reason" in analysis_result:
                        analysis_result["reason"] = "- é€™æ˜¯çŸ­ç¶²å€ï¼Œå¯èƒ½éš±è—çœŸå¯¦ç›®çš„åœ°\n" + str(analysis_result["reason"])
                    
                    # åœ¨å»ºè­°ä¸­å¼·èª¿è¬¹æ…
                    if "suggestion" in analysis_result:
                        analysis_result["suggestion"] = "- çŸ­ç¶²å€å¯èƒ½å°å‘é¢¨éšªç¶²ç«™ï¼Œè«‹ç‰¹åˆ¥å°å¿ƒ\n" + str(analysis_result["suggestion"])
                
                
                # ä¿®å¾©JSONé¡¯ç¤ºå•é¡Œ
                try:
                    # å˜—è©¦å°å…¥ä¸¦ä½¿ç”¨ä¿®å¾©å‡½æ•¸
                    from fix_json_display import fix_url_analysis_result
                    analysis_result = fix_url_analysis_result(analysis_result)
                    logger.info("ä½¿ç”¨ fix_json_display æ¨¡å¡Šè™•ç†äº† URL åˆ†æçµæœ")
                except ImportError:
                    logger.warning("ç„¡æ³•å°å…¥ fix_json_display æ¨¡å¡Š")
                
                # ç¢ºä¿æ‰€æœ‰å¿…è¦å­—æ®µéƒ½æœ‰å€¼
                if not analysis_result.get("reason"):
                    analysis_result["reason"] = "ç„¡å…·é«”åŸå› èªªæ˜"
                if not analysis_result.get("purpose"):
                    analysis_result["purpose"] = "æœªæä¾›ç¶²ç«™ç”¨é€”è³‡è¨Š"
                if not analysis_result.get("suggestion"):
                    analysis_result["suggestion"] = "è«‹è¬¹æ…ä½¿ç”¨ï¼Œå¦‚æœ‰ç–‘æ…®è«‹å‹¿é»æ“Š"
                
# ç¢ºä¿é¢¨éšªç­‰ç´šæœ‰å€¼
                if not analysis_result.get("risk_level") or analysis_result.get("risk_level") == "":
                    analysis_result["risk_level"] = "ä¸ç¢ºå®š"
                
                # å‰µå»ºFlex Messageé¡¯ç¤ºåˆ†æçµæœ
                flex_message = create_url_analysis_flex_message(analysis_result, url)
                
                # å¦‚æœæ˜¯é«˜é¢¨éšªæˆ–ä¸­é¢¨éšªçš„çŸ­ç¶²å€ï¼Œæ·»åŠ æ–‡å­—èªªæ˜
                if is_short_url and analysis_result.get("risk_level", "") in ["é«˜", "ä¸­"]:
                    text_warning = TextSendMessage(text=f"è¬¹æ…ä½¿ç”¨é€™å€‹é€£çµï¼å¾ç¶²å€ã€Œ{url}ã€ä¾†çœ‹ï¼Œé€™å€‹ç¶²å€æ¯”æ­£å¸¸ç¶²å€çŸ­ï¼Œä¸”ã€Œ{'æœªä½¿ç”¨' if not url.startswith('https') else 'é›–ä½¿ç”¨'}ã€å®‰å…¨é€£ç·šã€‚çŸ­ç¶²å€å¸¸è¢«ç”¨ä¾†æ©é£¾ä¸æ³•è¡Œç‚ºï¼Œå»ºè­°ä¸è¦é»æ“Šæˆ–è¼¸å…¥ä»»ä½•å€‹äººè³‡æ–™ï¼Œç‰¹åˆ¥æ˜¯é‡‘èç›¸é—œè³‡è¨Šã€‚")
                    line_bot_api.reply_message(event.reply_token, [flex_message, text_warning])
                else:
                    line_bot_api.reply_message(event.reply_token, flex_message)
#             try:
                pass
#             except Exception as e:
                logger.error(f"URLåˆ†æé¡¯ç¤ºéç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤: {e}")
                safe_message = TextSendMessage(text=f"åˆ†ææ­¤ç¶²å€æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚å»ºè­°æ‚¨è¬¹æ…ä½¿ç”¨ä»»ä½•ä¸ç†Ÿæ‚‰çš„é€£çµï¼Œå°¤å…¶æ˜¯çŸ­ç¶²å€æˆ–è¦æ±‚å€‹äººè³‡æ–™çš„ç¶²ç«™ã€‚")
                line_bot_api.reply_message(event.reply_token, safe_message)
            return
        else:
            # å¦‚æœæ‰¾ä¸åˆ°URLï¼Œè«‹æ±‚ç”¨æˆ¶æä¾›URL
            response_message = "è«‹æä¾›æ‚¨æƒ³è¦åˆ†æçš„ç¶²å€é€£çµï¼Œä¾‹å¦‚ï¼šã€Œåˆ†æé€™å€‹ç¶²ç«™ https://example.comã€"
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text=response_message))
            return
    
    # æª¢æŸ¥æ˜¯å¦ç‚ºé¦–æ¬¡å°è©±çš„ç”¨æˆ¶
    is_first_time = user_id not in first_time_chatters
    if is_first_time:
        first_time_chatters.add(user_id)
        logger.info(f"User {user_id} is chatting for the first time")

    # æ›´æ–°ç”¨æˆ¶æœ€å¾ŒèŠå¤©æ™‚é–“
    user_last_chat_time[user_id] = current_time

    # 0. æª¢æŸ¥æ˜¯å¦æ­£åœ¨ç­‰å¾…ç”¨æˆ¶å°æŸè¨Šæ¯æä¾›æ¾„æ¸…
    pending_state = user_pending_analysis.get(user_id)
    if pending_state and pending_state.get("waiting_for_clarification"):
        logger.info(f"User {user_id} is providing clarification for: {pending_state.get('original_message')}")
        clarification = user_message
        original_message_to_analyze = pending_state.get("original_message")
        
        # å°‡åŸå§‹è¨Šæ¯èˆ‡ç”¨æˆ¶çš„æ¾„æ¸…åˆä½µå¾Œé€²è¡Œåˆ†æ
        combined_message = f"ç”¨æˆ¶åŸå§‹è¨Šæ¯æ˜¯ï¼š\nã€Œ{original_message_to_analyze}ã€\n\nç”¨æˆ¶é‡å°æ­¤è¨Šæ¯ï¼Œè£œå……çš„ç–‘æ…®æˆ–èªªæ˜æ˜¯ï¼š\nã€Œ{clarification}ã€"
        logger.info(f"Combined message for analysis for user {user_id}: {combined_message}")

        analysis_result_text = detect_fraud_with_chatgpt(combined_message, display_name, user_id)
        analysis_data = parse_fraud_analysis(analysis_result_text)

        risk_level = analysis_data.get("risk_level", "ä¸ç¢ºå®š")
        fraud_type_identified = analysis_data.get("fraud_type", "æœªçŸ¥")
        explanation_text = analysis_data.get("explanation", "åˆ†æçµæœä¸å®Œæ•´ï¼Œè«‹è¬¹æ…åˆ¤æ–·ã€‚")
        suggestions_text = analysis_data.get("suggestions", "è«‹éš¨æ™‚ä¿æŒè­¦æƒ•ã€‚")

        reply_text_parts = [
            f"{display_name}æ‚¨å¥½ï¼Œé‡å°æ‚¨çš„è¨Šæ¯åŠè£œå……èªªæ˜ï¼Œæˆ‘çš„åˆ†æå¦‚ä¸‹ï¼š",
            f"é¢¨éšªç­‰ç´šï¼š{risk_level}",
            f"å¯èƒ½è©é¨™é¡å‹ï¼š{fraud_type_identified}"
        ]
        if explanation_text and explanation_text.strip() and not any(item in explanation_text for item in [risk_level, fraud_type_identified]):
             reply_text_parts.append(f"\n{explanation_text.strip()}")
        if suggestions_text and suggestions_text.strip():
             reply_text_parts.append(f"\nå»ºè­°ï¼š\n{suggestions_text.strip()}")
        
        reply_message_text = "\n".join(reply_text_parts)
        
        # æ·»åŠ åŠŸèƒ½æŒ‰éˆ•
        quick_reply = QuickReply(items=[
            QuickReplyButton(action=MessageAction(label="åˆ†æå…¶ä»–è¨Šæ¯", text="è«‹å¹«æˆ‘åˆ†æé€™å‰‡è¨Šæ¯ï¼š")),
            QuickReplyButton(action=MessageAction(label="é˜²è©é¨™èƒ½åŠ›æ¸¬è©¦", text="é¸å“ªé¡†åœŸè±†")),
            QuickReplyButton(action=MessageAction(label="è©é¨™é¡å‹æŸ¥è©¢", text="è©é¨™é¡å‹åˆ—è¡¨"))
        ])

        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=reply_message_text, quick_reply=quick_reply))
        firebase_manager.save_user_interaction(
            user_id, display_name, 
            f"Original: {original_message_to_analyze} | Clarification: {clarification}", 
            reply_message_text, 
            is_fraud_related=(risk_level.lower() not in ["ç„¡é¢¨éšª", "ä¸ç¢ºå®š", "éè©é¨™ç›¸é—œ", "ä½", "ä½é¢¨éšª"]), # æ“´å±•éè©é¨™ç›¸é—œåˆ¤æ–·
            fraud_type=fraud_type_identified, 
            risk_level=risk_level
        )
        if user_id in user_pending_analysis: # å†æ¬¡ç¢ºèªä»¥é˜²å¤šé‡è«‹æ±‚å•é¡Œ
            del user_pending_analysis[user_id] # åˆ†æå®Œæˆï¼Œæ¸…é™¤ç‹€æ…‹
        user_last_chat_time[user_id] = current_time # æ›´æ–°æœ€å¾Œäº’å‹•æ™‚é–“
        return

    # æª¢æŸ¥ç”¨æˆ¶æ˜¯å¦åœ¨éŠæˆ²ä¸­
    if user_id in user_game_state:
        logger.info(f"User {user_id} is in potato game state.")
        # æª¢æŸ¥æ˜¯å¦éœ€è¦é‡ç½®è‡ªå‹•å›è¦†è¨ˆæ™‚å™¨ (ä¾‹å¦‚è¶…é5åˆ†é˜æ²’æœ‰äº’å‹•)
        # é€™æ®µé‚è¼¯å¯ä»¥æ ¹æ“šå¯¦éš›éœ€æ±‚ä¿ç•™æˆ–èª¿æ•´
        # if user_id in user_last_chat_time and (current_time - user_last_chat_time[user_id]) > AUTO_REPLY_RESET_INTERVAL:
        # logger.info(f"Resetting auto-reply for user {user_id} due to inactivity.")
        # # å¯ä»¥åœ¨é€™è£¡ç™¼é€ä¸€å€‹æ–°çš„å•å€™èªæˆ–æç¤º
        # greeting_message = f"{display_name}æ‚¨å¥½ï¼åˆè¦‹é¢äº†ï¼Œæœ‰ä»€éº¼å¯ä»¥å¹«æ‚¨çš„å—ï¼Ÿè©¦è©¦çœ‹è¼¸å…¥ã€ŒåŠŸèƒ½ã€äº†è§£æˆ‘æœƒåšä»€éº¼ï¼"
        # line_bot_api.push_message(user_id, TextSendMessage(text=greeting_message))
        # firebase_manager.save_user_interaction(user_id, display_name, "Auto-reply reset", greeting_message, is_fraud_related=False)

        # æ›´æ–°ç”¨æˆ¶æœ€å¾ŒèŠå¤©æ™‚é–“ (å³ä¾¿åªæ˜¯ç”¨æˆ¶ç™¼è¨Šæ¯ï¼Œå°šæœªå›è¦†ï¼Œä¹Ÿæ›´æ–°)
        user_last_chat_time[user_id] = current_time
        
        # è™•ç†åŠŸèƒ½è©¢å•
        if any(keyword in user_message.lower() for keyword in function_inquiry_keywords):
            reply_text = f"{display_name}æ‚¨å¥½ï¼æˆ‘æ˜¯é˜²è©é¨™å°å¹«æ‰‹ï¼Œæˆ‘çš„åŠŸèƒ½åŒ…æ‹¬ï¼š\n\n" \
                        f"1ï¸âƒ£ è©é¨™é¢¨éšªåˆ†æï¼šæˆ‘å¯ä»¥åˆ†ææ‚¨æ”¶åˆ°çš„å¯ç–‘è¨Šæ¯ï¼Œè©•ä¼°æ˜¯å¦ç‚ºè©é¨™\n\n" \
                        f"2ï¸âƒ£ è©é¨™é¡å‹æŸ¥è©¢ï¼šæ‚¨å¯ä»¥è¼¸å…¥ã€Œè©é¨™é¡å‹åˆ—è¡¨ã€æŸ¥çœ‹å„ç¨®å¸¸è¦‹è©é¨™\n\n" \
                        f"3ï¸âƒ£ ã€Œé¸å“ªé¡†åœŸè±†ã€å°éŠæˆ²ï¼šé€šééŠæˆ²å­¸ç¿’è¾¨è­˜è©é¨™è¨Šæ¯\n\n" \
                        f"è«‹é¸æ“‡æ‚¨æƒ³å˜—è©¦çš„åŠŸèƒ½ï¼š"
            
            quick_reply = QuickReply(items=[
                QuickReplyButton(action=MessageAction(label="åˆ†æå¯ç–‘è¨Šæ¯", text="è«‹å¹«æˆ‘åˆ†æé€™å‰‡è¨Šæ¯ï¼š")),
                QuickReplyButton(action=MessageAction(label="é˜²è©é¨™èƒ½åŠ›æ¸¬è©¦", text="é¸å“ªé¡†åœŸè±†")),
                QuickReplyButton(action=MessageAction(label="è©é¨™é¡å‹æŸ¥è©¢", text="è©é¨™é¡å‹åˆ—è¡¨"))
            ])
            
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text=reply_text, quick_reply=quick_reply))
            firebase_manager.save_user_interaction(user_id, display_name, user_message, "å›è¦†åŠŸèƒ½èªªæ˜", is_fraud_related=False)
            return
        
        # è™•ç†éœ€è¦è¿½å•çš„æƒ…æ³ (ä¾‹å¦‚ç”¨æˆ¶æ˜ç¢ºè¡¨ç¤ºè¢«è©é¨™)
        if any(pattern in user_message.lower() for pattern in follow_up_patterns):
            follow_up_reply_text = (
                f"{display_name}æ‚¨å¥½ï¼è«‹ä¸è¦æ“”å¿ƒï¼Œæˆ‘äº†è§£æ‚¨å¯èƒ½æ­£åœ¨æ“”å¿ƒé‡åˆ°è©é¨™æƒ…æ³ã€‚\n\n"
                f"ç‚ºäº†èƒ½æ›´æº–ç¢ºåœ°å¹«åŠ©æ‚¨åˆ†æï¼Œè«‹æ‚¨å‘Šè¨´æˆ‘æ›´å¤šè©³ç´°æƒ…æ³ï¼š\n\n"
                f"â€¢ æ‚¨æ”¶åˆ°äº†ä»€éº¼å¯ç–‘è¨Šæ¯æˆ–é›»è©±ï¼Ÿ\n"
                f"â€¢ å°æ–¹æå‡ºäº†ä»€éº¼è¦æ±‚ï¼Ÿ\n"
                f"â€¢ æ‚¨æ˜¯å¦å·²ç¶“æä¾›å€‹äººè³‡æ–™æˆ–é€²è¡Œä»˜æ¬¾ï¼Ÿ\n\n"
                f"è«‹å°‡å¯ç–‘å…§å®¹åˆ†äº«çµ¦æˆ‘ï¼Œæˆ‘æœƒç«‹å³ç‚ºæ‚¨åˆ†æé¢¨éšªï¼\n\n"
                f"ã€æº«é¦¨æé†’ã€‘ï¼šè«‹ä¸€æ¬¡æ€§å°‡å®Œæ•´æƒ…æ³æè¿°æ¸…æ¥šï¼Œé¿å…åˆ†æˆå¤šå‰‡çŸ­è¨Šæ¯ç™¼é€ï¼Œé€™æ¨£æˆ‘æ‰èƒ½æ›´æº–ç¢ºåœ°ç†è§£ä¸¦åˆ†ææ‚¨é‡åˆ°çš„æƒ…æ³ã€‚"
            )
            
            quick_reply = QuickReply(items=[
                QuickReplyButton(action=MessageAction(label="åˆ†æå¯ç–‘è¨Šæ¯", text="è«‹å¹«æˆ‘åˆ†æé€™å‰‡è¨Šæ¯ï¼š")),
                QuickReplyButton(action=MessageAction(label="é˜²è©é¨™èƒ½åŠ›æ¸¬è©¦", text="é¸å“ªé¡†åœŸè±†")),
                QuickReplyButton(action=MessageAction(label="è©é¨™é¡å‹æŸ¥è©¢", text="è©é¨™é¡å‹åˆ—è¡¨"))
            ])
            
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text=follow_up_reply_text, quick_reply=quick_reply))
            firebase_manager.save_user_interaction(
                user_id, display_name, user_message, 
                "Responded to follow-up pattern with clarifying questions", 
                is_fraud_related=True 
            )
            return

    # è™•ç†ã€Œé¸å“ªé¡†åœŸè±†ã€éŠæˆ²è§¸ç™¼ (æ³¨æ„ï¼šé€™éƒ¨åˆ†ä»£ç¢¼å¾user_game_stateæ¢ä»¶å…§ç§»å‡º)
    if any(keyword in user_message.lower() for keyword in potato_game_trigger_keywords):
        logger.info(f"User {user_id} triggered potato game.")
        firebase_manager.save_user_interaction(
            user_id, display_name, user_message, 
            "å•Ÿå‹•ã€Œé¸å“ªé¡†åœŸè±†ã€éŠæˆ²", is_fraud_related=False
        )
        send_potato_game_question(user_id, event.reply_token)
        return

    # è™•ç†è©é¨™é¡å‹åˆ—è¡¨æŸ¥è©¢
    if user_message.lower() == "è©é¨™é¡å‹åˆ—è¡¨" or user_message.lower() == "è©é¨™é¡å‹":
        logger.info(f"User {user_id} is querying fraud types list")
        types_text = "ç›®å‰å·²æ”¶é›†çš„è©é¨™é¡å‹æœ‰ï¼š\n"
        for f_type, info in fraud_types.items():
            types_text += f"\nâš ï¸ {f_type}ï¼š\n{info['description']}\n"
        
        types_text += "\næƒ³äº†è§£ç‰¹å®šé¡å‹ï¼Œå¯ä»¥å•æˆ‘ã€Œä»€éº¼æ˜¯[è©é¨™é¡å‹]ã€å–”ï¼"

        quick_reply_items = []
        for f_type in list(fraud_types.keys())[:4]:  # åªå–å‰4å€‹è©é¨™é¡å‹ä½œç‚ºå¿«é€Ÿå›è¦†
            quick_reply_items.append(QuickReplyButton(action=MessageAction(label=f_type, text=f"ä»€éº¼æ˜¯{f_type}")))

        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=types_text, quick_reply=QuickReply(items=quick_reply_items) if quick_reply_items else None))
        firebase_manager.save_user_interaction(user_id, display_name, user_message, "Provided list of fraud types", is_fraud_related=False)
        return
        
    # è™•ç†ç‰¹å®šè©é¨™é¡å‹è³‡è¨ŠæŸ¥è©¢ (ä¾‹å¦‚ "ä»€éº¼æ˜¯ç¶²è·¯è³¼ç‰©è©é¨™")
    specific_type_query_match = re.match(r"^(ä»€éº¼æ˜¯|æŸ¥è©¢|æˆ‘æƒ³äº†è§£|æˆ‘æƒ³çŸ¥é“)(.+è©é¨™)$", user_message.strip())
    if specific_type_query_match:
        query_type = specific_type_query_match.group(2).strip()
        logger.info(f"User {user_id} is querying about specific fraud type: {query_type}")
        
        matched_fraud_type = None
        for f_type, info in fraud_types.items():
            if query_type in f_type or f_type in query_type:
                matched_fraud_type = f_type
                break
        
        if matched_fraud_type:
            info = fraud_types[matched_fraud_type]
            response_text = f"âš ï¸ {matched_fraud_type} âš ï¸\n\n{info['description']}\n\n"
            
            if info.get('examples') and len(info['examples']) > 0:
                response_text += "ğŸ“‹ æ¡ˆä¾‹ï¼š\n" + info['examples'][0] + "\n\n"
            
            if info.get('sop') and len(info['sop']) > 0:
                response_text += "ğŸ›¡ï¸ é˜²ç¯„æ–¹æ³•ï¼š\n" + "\n".join(info['sop'][:5]) + "\n"
            
            quick_reply = QuickReply(items=[
                QuickReplyButton(action=MessageAction(label="æŸ¥çœ‹å…¶ä»–è©é¨™é¡å‹", text="è©é¨™é¡å‹åˆ—è¡¨")),
                QuickReplyButton(action=MessageAction(label="é˜²è©é¨™èƒ½åŠ›æ¸¬è©¦", text="é¸å“ªé¡†åœŸè±†")),
                QuickReplyButton(action=MessageAction(label="åˆ†æå¯ç–‘è¨Šæ¯", text="è«‹å¹«æˆ‘åˆ†æé€™å‰‡è¨Šæ¯ï¼š"))
            ])
            
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text=response_text, quick_reply=quick_reply))
            firebase_manager.save_user_interaction(user_id, display_name, user_message, f"Provided info about {matched_fraud_type}", is_fraud_related=False)
            return
        else:
            # æœªæ‰¾åˆ°åŒ¹é…çš„è©é¨™é¡å‹ï¼Œçµ¦å‡ºä¸€èˆ¬æ€§å›è¦†
            response_text = f"æŠ±æ­‰ï¼Œæˆ‘ç›®å‰æ²’æœ‰é—œæ–¼ã€Œ{query_type}ã€çš„è©³ç´°è³‡è¨Šã€‚\n\nä»¥ä¸‹æ˜¯æˆ‘å·²æ”¶é›†çš„è©é¨™é¡å‹ï¼Œæ‚¨å¯ä»¥æŸ¥è©¢é€™äº›ï¼š"
            for f_type in fraud_types.keys():
                response_text += f"\n- {f_type}"
            
            quick_reply = QuickReply(items=[
                QuickReplyButton(action=MessageAction(label="æŸ¥çœ‹è©é¨™é¡å‹åˆ—è¡¨", text="è©é¨™é¡å‹åˆ—è¡¨")),
                QuickReplyButton(action=MessageAction(label="é˜²è©é¨™èƒ½åŠ›æ¸¬è©¦", text="é¸å“ªé¡†åœŸè±†"))
            ])
            
            line_bot_api.reply_message(event.reply_token, TextSendMessage(text=response_text, quick_reply=quick_reply))
            firebase_manager.save_user_interaction(user_id, display_name, user_message, "Responded to unknown fraud type query", is_fraud_related=False)
            return

    # æª¢æŸ¥æ˜¯å¦ç‚ºè«‹æ±‚åˆ†æçš„æç¤ºèª
    analysis_prompts = ["è«‹å¹«æˆ‘åˆ†æé€™å‰‡è¨Šæ¯ï¼š", "å¹«æˆ‘åˆ†æé€™å‰‡è¨Šæ¯", "åˆ†æé€™å‰‡è¨Šæ¯", "å¹«æˆ‘åˆ†æè¨Šæ¯"]
    if any(user_message.strip() == prompt or user_message.strip() == prompt.rstrip("ï¼š") for prompt in analysis_prompts):
        logger.info(f"User {user_id} requested message analysis but didn't provide message content")
        prompt_reply = f"{display_name}ï¼Œæ‚¨å¥½ï¼è«‹å°‡æ‚¨æƒ³è¦åˆ†æçš„å¯ç–‘è¨Šæ¯å®Œæ•´ç™¼é€çµ¦æˆ‘ï¼Œæˆ‘æœƒç«‹å³ç‚ºæ‚¨é€²è¡Œè©é¨™é¢¨éšªè©•ä¼°ã€‚\n\nä¾‹å¦‚ï¼š\n- éŠ€è¡Œé€šçŸ¥æ‚¨çš„å¸³æˆ¶ç•°å¸¸éœ€è¦æ“ä½œATM\n- ä¸æ˜ç¶²æ‹è³£å®¶è¦æ±‚ç§ä¸‹äº¤æ˜“\n- é™Œç”Ÿäººå‚³ä¾†çš„æŠ•è³‡ç†è²¡è¨Šæ¯\nç­‰ç­‰ã€‚"
        
        quick_reply = QuickReply(items=[
            QuickReplyButton(action=MessageAction(label="é˜²è©é¨™èƒ½åŠ›æ¸¬è©¦", text="é¸å“ªé¡†åœŸè±†")),
            QuickReplyButton(action=MessageAction(label="è©é¨™é¡å‹æŸ¥è©¢", text="è©é¨™é¡å‹åˆ—è¡¨"))
        ])
        
        line_bot_api.reply_message(event.reply_token, TextSendMessage(text=prompt_reply, quick_reply=quick_reply))
        firebase_manager.save_user_interaction(user_id, display_name, user_message, "Responded to analysis request prompt", is_fraud_related=False)
        return

    # æª¢æŸ¥æ˜¯å¦éœ€è¦å°æ¶ˆæ¯é€²è¡Œè©é¨™åˆ†æçš„é‚è¼¯

    def should_perform_fraud_analysis(user_message):
        # 1. æª¢æŸ¥æ˜¯å¦åŒ…å«å¸¸è¦‹å•å€™è©
        common_greetings = ["ä½ å¥½", "å—¨", "å“ˆå›‰", "å˜¿", "hi", "hello", "hey", "æ—©å®‰", "åˆå®‰", "æ™šå®‰"]
        if user_message.lower() in common_greetings or (len(user_message) <= 5 and any(greeting in user_message.lower() for greeting in common_greetings)):
            return False
            
        # 2. æª¢æŸ¥æ˜¯å¦æ˜¯åŠŸèƒ½ç›¸é—œæŒ‡ä»¤
        if any(keyword in user_message.lower() for keyword in function_inquiry_keywords + potato_game_trigger_keywords) or "è©é¨™é¡å‹" in user_message:
            return False
            
        # 3. æª¢æŸ¥æ˜¯å¦æ˜¯è·Ÿè¸ªæ¨¡å¼çš„å•å¥
        if any(pattern in user_message.lower() for pattern in follow_up_patterns):
            return True
            
        # 4. æª¢æŸ¥æ˜¯å¦æ˜¯è«‹æ±‚åˆ†æçš„æ˜é¡¯ç‰¹å¾µ
        analysis_indicators = ["å¹«æˆ‘åˆ†æ", "å¹«å¿™çœ‹çœ‹", "é€™æ˜¯ä¸æ˜¯è©é¨™", "é€™æ˜¯çœŸçš„å—", "é€™å¯é å—", "åˆ†æä¸€ä¸‹", "é€™æ¨£æ˜¯è©é¨™å—"]
        if any(indicator in user_message for indicator in analysis_indicators):
            return True
            
        # 5. æª¢æŸ¥æ˜¯å¦åŒ…å«ç‰¹å®šè©é¨™ç›¸é—œé—œéµè©
        # åªæœ‰ä½¿ç”¨è€…æ˜ç¢ºè¡¨ç¤ºéœ€è¦åˆ†æï¼Œæˆ–è€…æ–‡æœ¬åŒ…å«å¤šå€‹è©é¨™é—œéµè©æ‰é€²è¡Œåˆ†æ
        fraud_related_keywords = ["è©é¨™", "è¢«é¨™", "é¨™å­", "å¯ç–‘", "è½‰å¸³", "åŒ¯æ¬¾", "éŠ€è¡Œå¸³è™Ÿ", "å€‹è³‡", "èº«ä»½è­‰", "å¯†ç¢¼", 
                                "é€šçŸ¥", "ä¸­ç", "è²¸æ¬¾", "æŠ•è³‡", "æ€¥éœ€", "å¹«æˆ‘è™•ç†", "æ€¥ç”¨", "è§£é™¤è¨­å®š", "ææ¬¾å¡", 
                                "ç›£ç®¡å¸³æˆ¶", "è§£å‡", "å®‰å…¨å¸³æˆ¶", "ç°½è­‰", "ä¿è­‰é‡‘", "é•æ³•", "æ´—éŒ¢", "è­¦å¯Ÿ", "æª¢å¯Ÿå®˜"]
                                
        # è¦æ±‚è‡³å°‘åŒ…å«å…©å€‹è©é¨™ç›¸é—œé—œéµè©
        keyword_count = sum(1 for keyword in fraud_related_keywords if keyword in user_message)
        if keyword_count >= 2:
            return True
            
        # é—œéµè®ŠåŒ–ï¼šä¸å†ä½¿ç”¨ã€Œæ¶ˆæ¯é•·åº¦>20ã€ä½œç‚ºè‡ªå‹•åˆ†æçš„æ¢ä»¶
        # æ›´æ˜ç¢ºçš„åˆ¤æ–·æ˜¯ç”¨æˆ¶æ˜¯å¦å¯¦éš›è«‹æ±‚åˆ†æè©é¨™é¢¨éšª
            
        # 6. é è¨­ä¸é€²è¡Œè©é¨™åˆ†æï¼Œå°‡è¨Šæ¯ä½œç‚ºä¸€èˆ¬é–’èŠè™•ç†
        return False

    # é è¨­ä½¿ç”¨ChatGPTé€²è¡Œé–’èŠå›æ‡‰æˆ–è©é¨™åˆ†æ
    logger.info(f"Message from {user_id}: {user_message} - Determining if fraud analysis is needed")
    
    # åˆ¤æ–·æ˜¯å¦éœ€è¦é€²è¡Œè©é¨™åˆ†æ
    if should_perform_fraud_analysis(user_message):
        logger.info(f"Performing fraud analysis for message from {user_id}: {user_message}")
        # ä½¿ç”¨ç¾æœ‰çš„è©é¨™åˆ†æé‚è¼¯ï¼Œå‚³å…¥user_id
        analysis_result_text = detect_fraud_with_chatgpt(user_message, display_name, user_id)
        analysis_data = parse_fraud_analysis(analysis_result_text)

        risk_level = analysis_data.get("risk_level", "ä¸ç¢ºå®š")
        fraud_type = analysis_data.get("fraud_type", "æœªçŸ¥")
        explanation = analysis_data.get("explanation", "åˆ†æçµæœä¸å®Œæ•´ï¼Œè«‹è¬¹æ…åˆ¤æ–·ã€‚")
        suggestions = analysis_data.get("suggestions", "è«‹éš¨æ™‚ä¿æŒè­¦æƒ•ã€‚")
        is_emerging = analysis_data.get("is_emerging", False)

        reply_text = f"æ ¹æ“šæˆ‘çš„åˆ†æï¼š\né¢¨éšªç­‰ç´šï¼š{risk_level}\nå¯èƒ½è©é¨™é¡å‹ï¼š{fraud_type}\n\n{explanation}\n\nå»ºè­°ï¼š\n{suggestions}"

        if is_emerging and fraud_type != "éè©é¨™ç›¸é—œ":
            emerging_text = "\n\nâš ï¸ é€™å¯èƒ½æ˜¯ä¸€ç¨®æ–°çš„è©é¨™æ‰‹æ³•ï¼Œæˆ‘å·²ç¶“è¨˜éŒ„ä¸‹ä¾†äº†ï¼Œè¬è¬æ‚¨çš„è³‡è¨Šï¼"
            reply_text += emerging_text
            firebase_manager.save_emerging_fraud_report(user_id, display_name, user_message, analysis_result_text)
            is_fraud_related = True
        elif fraud_type != "éè©é¨™ç›¸é—œ" and risk_level not in ["ç„¡é¢¨éšª", "ä½"]: 
            is_fraud_related = True
        else:
            is_fraud_related = False
    else:
        # ä½¿ç”¨ChatGPTé€²è¡Œé–’èŠå›æ‡‰
        logger.info(f"Using chat response for message from {user_id}: {user_message}")
        
        try:
            # ç²å–ç”¨æˆ¶æœ€è¿‘çš„å°è©±æ­·å²
            recent_history = firebase_manager.get_recent_interactions(user_id, limit=5)
            
            # æº–å‚™å°è©±æ­·å²æ¶ˆæ¯åˆ—è¡¨
            chat_history = []
            
            # ç³»çµ±æç¤ºæ¶ˆæ¯
            system_message = {
                "role": "system", 
                "content": "ä½ æ˜¯ä¸€ä½åç‚ºã€ŒåœŸè±†ã€çš„AIèŠå¤©æ©Ÿå™¨äººï¼Œä½ çš„é¢¨æ ¼å‹å–„ã€æº«æš–ä¸”è²¼å¿ƒã€‚ä½ éœ€è¦æ ¹æ“šä¹‹å‰çš„å°è©±æ­·å²ä¾†å›æ‡‰ç”¨æˆ¶ï¼Œæä¾›é€£è²«ä¸”è‡ªç„¶çš„å°è©±é«”é©—ã€‚ä½ æ˜¯é˜²è©é¨™å°ˆå®¶ï¼Œç•¶ç”¨æˆ¶è¨è«–å¯ç–‘è¨Šæ¯æ™‚ï¼Œè¦ä¿æŒè­¦è¦ºã€‚"
            }
            
            # å¦‚æœæˆåŠŸç²å–åˆ°æ­·å²å°è©±ï¼Œå‰‡ä½¿ç”¨å®ƒå€‘
            if recent_history:
                # å°‡æ­·å²å°è©±è½‰æ›ç‚ºChatGPTæ ¼å¼
                for interaction in recent_history:
                    # ç”¨æˆ¶æ¶ˆæ¯
                    if 'message' in interaction and interaction['message']:
                        chat_history.append({
                            "role": "user",
                            "content": interaction['message']
                        })
                    
                    # æ©Ÿå™¨äººå›æ‡‰
                    if 'response' in interaction and interaction['response']:
                        chat_history.append({
                            "role": "assistant",
                            "content": interaction['response']
                        })
                
                logger.info(f"æˆåŠŸä½¿ç”¨ç”¨æˆ¶æ­·å²å°è©±: {len(chat_history)} æ¢æ¶ˆæ¯")
            else:
                # å¦‚æœæ²’æœ‰æ­·å²å°è©±æˆ–ç™¼ç”ŸéŒ¯èª¤ï¼Œä½¿ç”¨ç©ºçš„æ­·å²
                logger.info("ç„¡æ³•ç²å–ç”¨æˆ¶æ­·å²å°è©±ï¼Œä½¿ç”¨ç©ºæ­·å²")
            
            # æ·»åŠ ç•¶å‰ç”¨æˆ¶æ¶ˆæ¯
            current_user_message = {
                "role": "user",
                "content": user_message
            }
            
            # æ§‹å»ºå®Œæ•´çš„æ¶ˆæ¯åˆ—è¡¨
            messages = [system_message] + chat_history + [current_user_message]
            
            # é™åˆ¶æ¶ˆæ¯æ•¸é‡ï¼Œé¿å…è¶…å‡ºAPIé™åˆ¶
            if len(messages) > 10:
                # ä¿ç•™ç³»çµ±æ¶ˆæ¯å’Œæœ€è¿‘çš„å°è©±
                messages = [system_message] + messages[-9:]
            
            logger.info(f"ä½¿ç”¨è¨˜æ†¶åŠŸèƒ½ï¼Œç¸½å…±æä¾› {len(messages)} æ¢æ¶ˆæ¯çµ¦ChatGPT")
            
            # ä½¿ç”¨æ›´å‹å–„çš„é–’èŠå›æ‡‰ä¸¦å¸¶æœ‰è¨˜æ†¶åŠŸèƒ½
            chat_response = openai.chat.completions.create(
                model=os.environ.get('OPENAI_MODEL', 'gpt-3.5-turbo'),
                messages=messages,
                temperature=0.7,
                max_tokens=200
            )
            
            chat_reply = chat_response.choices[0].message.content.strip()
            
            # åªåœ¨é¦–æ¬¡èŠå¤©æ™‚æ·»åŠ åŠŸèƒ½ä»‹ç´¹
            if is_first_time:
                introduction = f"\n\næˆ‘æ˜¯é˜²è©é¨™æ©Ÿå™¨äººã€ŒåœŸè±†ã€ï¼Œèƒ½å¹«æ‚¨ï¼š\n1ï¸âƒ£ åˆ†æå¯ç–‘è¨Šæ¯\n2ï¸âƒ£ æ¸¬è©¦æ‚¨çš„é˜²è©é¨™èƒ½åŠ›\n3ï¸âƒ£ æŸ¥è©¢å„é¡è©é¨™æ‰‹æ³•"
                reply_text = chat_reply + introduction
            else:
                reply_text = chat_reply
            
            is_fraud_related = False
            
            pass
            logger.error(f"é–’èŠå›æ‡‰éŒ¯èª¤: {e}")
            # å¦‚æœé–’èŠå›æ‡‰å¤±æ•—ï¼Œä½¿ç”¨ç°¡å–®çš„å•å€™
            greetings = ["æ‚¨å¥½ï¼", "å—¨ï¼", "å“ˆå›‰ï¼", "å¾ˆé«˜èˆˆè¦‹åˆ°æ‚¨ï¼", "æ‚¨å¥½å‘€ï¼"]
            
            # åªåœ¨é¦–æ¬¡èŠå¤©æ™‚æ·»åŠ åŠŸèƒ½ä»‹ç´¹
            if is_first_time:
                reply_text = f"{random.choice(greetings)}æœ‰ä»€éº¼æˆ‘èƒ½å¹«æ‚¨çš„å—ï¼Ÿæ‚¨å¯ä»¥è¼¸å…¥ã€ŒåŠŸèƒ½ã€ä¾†äº†è§£æˆ‘èƒ½åšä»€éº¼ã€‚"
            else:
                reply_text = f"{random.choice(greetings)}æœ‰ä»€éº¼æˆ‘èƒ½å¹«æ‚¨çš„å—ï¼Ÿ"
            
            is_fraud_related = False
    
    # æ·»åŠ åŠŸèƒ½æŒ‰éˆ•åˆ°æ‰€æœ‰å›è¦†
    quick_reply = QuickReply(items=[
        QuickReplyButton(action=MessageAction(label="åˆ†æå¯ç–‘è¨Šæ¯", text="è«‹å¹«æˆ‘åˆ†æé€™å‰‡è¨Šæ¯ï¼š")),
        QuickReplyButton(action=MessageAction(label="é˜²è©é¨™èƒ½åŠ›æ¸¬è©¦", text="é¸å“ªé¡†åœŸè±†")),
        QuickReplyButton(action=MessageAction(label="è©é¨™é¡å‹æŸ¥è©¢", text="è©é¨™é¡å‹åˆ—è¡¨"))
    ])
    
    line_bot_api.reply_message(event.reply_token, TextSendMessage(text=reply_text, quick_reply=quick_reply))
    
    # ä¿å­˜äº’å‹•è¨˜éŒ„åˆ°Firebase
    firebase_manager.save_user_interaction(
        user_id, display_name, user_message, reply_text,
        is_fraud_related=is_fraud_related,
        fraud_type=fraud_type if is_fraud_related else None,
        risk_level=risk_level if is_fraud_related else None
    )



@handler.add(PostbackEvent)

def handle_postback(event):
    user_id = event.source.user_id
    reply_token = event.reply_token
    postback_data_str = event.postback.data
    
    logger.info(f"æ¥æ”¶åˆ°ä¾†è‡ª {user_id} çš„ Postback: {postback_data_str}")
    
    # è§£æ postback_data (e.g., "action=value&key=value")
    # Ensure robust parsing for various possible postback data formats
    try:
        data_params = dict(item.split("=", 1) for item in postback_data_str.split("&") if "=" in item)
    except ValueError:
        logger.error(f"ç„¡æ³•è§£æ Postback data: {postback_data_str}")
        data_params = {} # Avoid crashing if data is malformed

    action = data_params.get('action')
    uid_from_data = data_params.get('uid')

    if uid_from_data and uid_from_data != user_id:
       logger.warning(f"User ID mismatch in postback: event.source.user_id={user_id}, data_params.uid={uid_from_data}. Using event.source.user_id.")
       # Prefer user_id from event source for security and consistency.

    profile = get_user_profile(user_id) # Get profile for display name if needed
    display_name = profile.display_name if profile and profile.display_name else "ä½¿ç”¨è€…"

    if action == 'potato_game_answer':
        logger.info(f"User {display_name}({user_id}) answered potato game.")
        # Log game interaction before handling answer
        chosen_option = data_params.get('chosen_option_id', 'N/A')
        firebase_manager.save_user_interaction(
            user_id, display_name, f"PotatoGame_Answer:{chosen_option}", 
            "è™•ç†ã€Œé¸å“ªé¡†åœŸè±†ã€éŠæˆ²ç­”æ¡ˆ", is_fraud_related=False 
        )
        handle_potato_game_answer(user_id, reply_token, data_params)
        return
    elif action == 'start_potato_game':
        logger.info(f"User {display_name}({user_id}) wants to play potato game again.")
        firebase_manager.save_user_interaction(
            user_id, display_name, "PotatoGame_Restart", 
            "é‡æ–°é–‹å§‹ã€Œé¸å“ªé¡†åœŸè±†ã€éŠæˆ²", is_fraud_related=False
        )
        send_potato_game_question(user_id, reply_token)
        return
    
    # ä½ å¯ä»¥åœ¨é€™è£¡æ·»åŠ æ›´å¤šçš„ postback è™•ç†é‚è¼¯
    # ä¾‹å¦‚è™•ç†å…¶ä»– Flex Message æŒ‰éˆ•çš„é»æ“Šäº‹ä»¶

    else:
        logger.warning(f"æœªçŸ¥çš„ Postback action: {action} from user {user_id}")
        # line_bot_api.reply_message(reply_token, TextSendMessage(text="æ”¶åˆ°ä¸€å€‹æˆ‘ç„¡æ³•è™•ç†çš„æŒ‡ä»¤ï¼Œè«‹å†è©¦ä¸€æ¬¡ã€‚"))
        # Decided not to reply for unknown postbacks to avoid interrupting other flows or causing confusion.
        # If specific unhandled postbacks need a reply, add explicit conditions.

# è¼‰å…¥è©é¨™é¡Œåº«
POTATO_GAME_QUESTIONS_DB = "potato_game_questions.json"
potato_game_questions = []

def load_potato_game_questions():
    global potato_game_questions
    try:
        # è¨˜éŒ„è¼‰å…¥å‰çš„è·¯å¾‘ä¿¡æ¯
        file_path = os.path.abspath(POTATO_GAME_QUESTIONS_DB)
        logger.info(f"å˜—è©¦å¾è·¯å¾‘è®€å–é¡Œåº«æ–‡ä»¶: {file_path}")
        logger.info(f"ç•¶å‰å·¥ä½œç›®éŒ„: {os.getcwd()}")
        
        # æª¢æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if not os.path.exists(file_path):
            logger.error(f"æ–‡ä»¶ä¸å­˜åœ¨: {file_path}")
            potato_game_questions = []
            return
            
        with open(POTATO_GAME_QUESTIONS_DB, 'r', encoding='utf-8') as f:
            data = json.load(f)
            
            # è™•ç†ä¸åŒçš„JSONçµæ§‹
            all_questions = []
            
            if isinstance(data, dict) and "questions" in data:
                # è™•ç†é ‚å±¤questions
                top_questions = data.get("questions", [])
                
                for q in top_questions:
                    # æª¢æŸ¥æ˜¯å¦æœ‰åµŒå¥—çš„questionsæ•¸çµ„
                    if isinstance(q, dict) and "questions" in q:
                        # å°‡åµŒå¥—çš„questionsæ·»åŠ åˆ°ç¸½é¡Œåº«
                        nested_questions = q.get("questions", [])
                        all_questions.extend(nested_questions)
                        logger.info(f"ç™¼ç¾åµŒå¥—é¡Œç›®ï¼š{len(nested_questions)}é¡Œ")
                    else:
                        # å°‡é ‚å±¤é¡Œç›®æ·»åŠ åˆ°ç¸½é¡Œåº«
                        all_questions.append(q)
            
            potato_game_questions = all_questions
            
        # ç¢ºèªæ–‡ä»¶å…§å®¹
        first_three_questions = []
        for i, q in enumerate(potato_game_questions[:3]):
            first_three_questions.append(f"é¡Œç›®ID: {q.get('id')}, è©é¨™é¡å‹: {q.get('fraud_type')}")
            
        logger.info(f"æˆåŠŸå¾ {POTATO_GAME_QUESTIONS_DB} åŠ è¼‰è©é¨™é¡Œåº«ï¼Œå…± {len(potato_game_questions)} é“é¡Œç›®")
        logger.info(f"å‰ä¸‰å€‹é¡Œç›®: {', '.join(first_three_questions)}")
        logger.info(f"é¡Œåº«ä¸­é¸é …ä¿¡æ¯: æœ‰é è¨­é¸é …çš„é¡Œç›®æ•¸é‡: {sum(1 for q in potato_game_questions if 'options' in q and q['options'] and 'correct_option' in q)}")
    except FileNotFoundError:
        logger.warning(f"è©é¨™é¡Œåº«æ–‡ä»¶ {POTATO_GAME_QUESTIONS_DB} æœªæ‰¾åˆ°ã€‚")
        potato_game_questions = []
    except json.JSONDecodeError:
        logger.error(f"è§£æè©é¨™é¡Œåº«æ–‡ä»¶ {POTATO_GAME_QUESTIONS_DB} å¤±æ•—ã€‚")
        potato_game_questions = []
        pass
        logger.error(f"åŠ è¼‰è©é¨™é¡Œåº«æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤: {e}")
        potato_game_questions = []

load_fraud_tactics()
load_potato_game_questions()  # åŠ è¼‰é¡Œåº«

if __name__ == "__main__":
    # ç¢ºä¿åœ¨æœå‹™å•Ÿå‹•æ™‚é‡æ–°åŠ è¼‰é¡Œåº«
    load_fraud_tactics()
    load_potato_game_questions()
    
    # æ‰“å°é¡Œåº«åŠ è¼‰çµæœ
    logger.info(f"æœå‹™å•Ÿå‹•æ™‚è¼‰å…¥é¡Œåº«ï¼špotato_game_questions åŒ…å« {len(potato_game_questions)} é“é¡Œç›®")
    logger.info(f"é¡Œåº«ä¸­æœ‰é¸é …çš„é¡Œç›®æ•¸é‡: {sum(1 for q in potato_game_questions if 'options' in q and q['options'] and 'correct_option' in q)}")
    if potato_game_questions:
        logger.info(f"é¡Œåº«è·¯å¾‘: {os.path.abspath(POTATO_GAME_QUESTIONS_DB)}")
        logger.info(f"å·¥ä½œç›®éŒ„: {os.getcwd()}")
        
    port = int(os.environ.get("PORT", 8080))
    app.run(host="0.0.0.0", port=port) 